// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.12.4
// source: hub/hub_mobile.proto

package hub

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	common "github.com/ivere27/nitella/pkg/api/common"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MobileService_RegisterNodeViaCSR_FullMethodName = "/nitella.hub.MobileService/RegisterNodeViaCSR"
	MobileService_ListNodes_FullMethodName          = "/nitella.hub.MobileService/ListNodes"
	MobileService_GetNode_FullMethodName            = "/nitella.hub.MobileService/GetNode"
	MobileService_RegisterNode_FullMethodName       = "/nitella.hub.MobileService/RegisterNode"
	MobileService_ApproveNode_FullMethodName        = "/nitella.hub.MobileService/ApproveNode"
	MobileService_DeleteNode_FullMethodName         = "/nitella.hub.MobileService/DeleteNode"
	MobileService_SendCommand_FullMethodName        = "/nitella.hub.MobileService/SendCommand"
	MobileService_StreamMetrics_FullMethodName      = "/nitella.hub.MobileService/StreamMetrics"
	MobileService_GetMetricsHistory_FullMethodName  = "/nitella.hub.MobileService/GetMetricsHistory"
	MobileService_StreamAlerts_FullMethodName       = "/nitella.hub.MobileService/StreamAlerts"
	MobileService_StreamSignaling_FullMethodName    = "/nitella.hub.MobileService/StreamSignaling"
	MobileService_CreateProxyConfig_FullMethodName  = "/nitella.hub.MobileService/CreateProxyConfig"
	MobileService_ListProxyConfigs_FullMethodName   = "/nitella.hub.MobileService/ListProxyConfigs"
	MobileService_DeleteProxyConfig_FullMethodName  = "/nitella.hub.MobileService/DeleteProxyConfig"
	MobileService_PushRevision_FullMethodName       = "/nitella.hub.MobileService/PushRevision"
	MobileService_GetRevision_FullMethodName        = "/nitella.hub.MobileService/GetRevision"
	MobileService_ListRevisions_FullMethodName      = "/nitella.hub.MobileService/ListRevisions"
	MobileService_FlushRevisions_FullMethodName     = "/nitella.hub.MobileService/FlushRevisions"
)

// MobileServiceClient is the client API for MobileService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MobileServiceClient interface {
	// Node registration via CSR (Courier mode)
	RegisterNodeViaCSR(ctx context.Context, in *RegisterNodeViaCSRRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Node Management (owner's nodes only)
	ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (*ListNodesResponse, error)
	GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*Node, error)
	RegisterNode(ctx context.Context, in *RegisterNodeRequest, opts ...grpc.CallOption) (*RegisterNodeResponse, error)
	ApproveNode(ctx context.Context, in *ApproveNodeRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...grpc.CallOption) (*Empty, error)
	// Commands (forwarded to owner's nodes)
	SendCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandResponse, error)
	// Real-time Streams
	StreamMetrics(ctx context.Context, in *StreamMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[EncryptedMetrics], error)
	GetMetricsHistory(ctx context.Context, in *GetMetricsHistoryRequest, opts ...grpc.CallOption) (*GetMetricsHistoryResponse, error)
	StreamAlerts(ctx context.Context, in *StreamAlertsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[common.Alert], error)
	StreamSignaling(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SignalMessage, SignalMessage], error)
	// Proxy Management (Zero-Trust: encrypted content, Hub only sees IDs)
	CreateProxyConfig(ctx context.Context, in *CreateProxyConfigRequest, opts ...grpc.CallOption) (*CreateProxyConfigResponse, error)
	ListProxyConfigs(ctx context.Context, in *ListProxyConfigsRequest, opts ...grpc.CallOption) (*ListProxyConfigsResponse, error)
	DeleteProxyConfig(ctx context.Context, in *DeleteProxyConfigRequest, opts ...grpc.CallOption) (*Empty, error)
	// Revision Management (E2E encrypted)
	PushRevision(ctx context.Context, in *PushRevisionRequest, opts ...grpc.CallOption) (*PushRevisionResponse, error)
	GetRevision(ctx context.Context, in *GetRevisionRequest, opts ...grpc.CallOption) (*GetRevisionResponse, error)
	ListRevisions(ctx context.Context, in *ListRevisionsRequest, opts ...grpc.CallOption) (*ListRevisionsResponse, error)
	FlushRevisions(ctx context.Context, in *FlushRevisionsRequest, opts ...grpc.CallOption) (*FlushRevisionsResponse, error)
}

type mobileServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMobileServiceClient(cc grpc.ClientConnInterface) MobileServiceClient {
	return &mobileServiceClient{cc}
}

func (c *mobileServiceClient) RegisterNodeViaCSR(ctx context.Context, in *RegisterNodeViaCSRRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileService_RegisterNodeViaCSR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileServiceClient) ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (*ListNodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNodesResponse)
	err := c.cc.Invoke(ctx, MobileService_ListNodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileServiceClient) GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*Node, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Node)
	err := c.cc.Invoke(ctx, MobileService_GetNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileServiceClient) RegisterNode(ctx context.Context, in *RegisterNodeRequest, opts ...grpc.CallOption) (*RegisterNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterNodeResponse)
	err := c.cc.Invoke(ctx, MobileService_RegisterNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileServiceClient) ApproveNode(ctx context.Context, in *ApproveNodeRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, MobileService_ApproveNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileServiceClient) DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, MobileService_DeleteNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileServiceClient) SendCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommandResponse)
	err := c.cc.Invoke(ctx, MobileService_SendCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileServiceClient) StreamMetrics(ctx context.Context, in *StreamMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[EncryptedMetrics], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MobileService_ServiceDesc.Streams[0], MobileService_StreamMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamMetricsRequest, EncryptedMetrics]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MobileService_StreamMetricsClient = grpc.ServerStreamingClient[EncryptedMetrics]

func (c *mobileServiceClient) GetMetricsHistory(ctx context.Context, in *GetMetricsHistoryRequest, opts ...grpc.CallOption) (*GetMetricsHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMetricsHistoryResponse)
	err := c.cc.Invoke(ctx, MobileService_GetMetricsHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileServiceClient) StreamAlerts(ctx context.Context, in *StreamAlertsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[common.Alert], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MobileService_ServiceDesc.Streams[1], MobileService_StreamAlerts_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamAlertsRequest, common.Alert]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MobileService_StreamAlertsClient = grpc.ServerStreamingClient[common.Alert]

func (c *mobileServiceClient) StreamSignaling(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SignalMessage, SignalMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MobileService_ServiceDesc.Streams[2], MobileService_StreamSignaling_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SignalMessage, SignalMessage]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MobileService_StreamSignalingClient = grpc.BidiStreamingClient[SignalMessage, SignalMessage]

func (c *mobileServiceClient) CreateProxyConfig(ctx context.Context, in *CreateProxyConfigRequest, opts ...grpc.CallOption) (*CreateProxyConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateProxyConfigResponse)
	err := c.cc.Invoke(ctx, MobileService_CreateProxyConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileServiceClient) ListProxyConfigs(ctx context.Context, in *ListProxyConfigsRequest, opts ...grpc.CallOption) (*ListProxyConfigsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProxyConfigsResponse)
	err := c.cc.Invoke(ctx, MobileService_ListProxyConfigs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileServiceClient) DeleteProxyConfig(ctx context.Context, in *DeleteProxyConfigRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, MobileService_DeleteProxyConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileServiceClient) PushRevision(ctx context.Context, in *PushRevisionRequest, opts ...grpc.CallOption) (*PushRevisionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PushRevisionResponse)
	err := c.cc.Invoke(ctx, MobileService_PushRevision_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileServiceClient) GetRevision(ctx context.Context, in *GetRevisionRequest, opts ...grpc.CallOption) (*GetRevisionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRevisionResponse)
	err := c.cc.Invoke(ctx, MobileService_GetRevision_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileServiceClient) ListRevisions(ctx context.Context, in *ListRevisionsRequest, opts ...grpc.CallOption) (*ListRevisionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRevisionsResponse)
	err := c.cc.Invoke(ctx, MobileService_ListRevisions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileServiceClient) FlushRevisions(ctx context.Context, in *FlushRevisionsRequest, opts ...grpc.CallOption) (*FlushRevisionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FlushRevisionsResponse)
	err := c.cc.Invoke(ctx, MobileService_FlushRevisions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MobileServiceServer is the server API for MobileService service.
// All implementations must embed UnimplementedMobileServiceServer
// for forward compatibility.
type MobileServiceServer interface {
	// Node registration via CSR (Courier mode)
	RegisterNodeViaCSR(context.Context, *RegisterNodeViaCSRRequest) (*empty.Empty, error)
	// Node Management (owner's nodes only)
	ListNodes(context.Context, *ListNodesRequest) (*ListNodesResponse, error)
	GetNode(context.Context, *GetNodeRequest) (*Node, error)
	RegisterNode(context.Context, *RegisterNodeRequest) (*RegisterNodeResponse, error)
	ApproveNode(context.Context, *ApproveNodeRequest) (*Empty, error)
	DeleteNode(context.Context, *DeleteNodeRequest) (*Empty, error)
	// Commands (forwarded to owner's nodes)
	SendCommand(context.Context, *CommandRequest) (*CommandResponse, error)
	// Real-time Streams
	StreamMetrics(*StreamMetricsRequest, grpc.ServerStreamingServer[EncryptedMetrics]) error
	GetMetricsHistory(context.Context, *GetMetricsHistoryRequest) (*GetMetricsHistoryResponse, error)
	StreamAlerts(*StreamAlertsRequest, grpc.ServerStreamingServer[common.Alert]) error
	StreamSignaling(grpc.BidiStreamingServer[SignalMessage, SignalMessage]) error
	// Proxy Management (Zero-Trust: encrypted content, Hub only sees IDs)
	CreateProxyConfig(context.Context, *CreateProxyConfigRequest) (*CreateProxyConfigResponse, error)
	ListProxyConfigs(context.Context, *ListProxyConfigsRequest) (*ListProxyConfigsResponse, error)
	DeleteProxyConfig(context.Context, *DeleteProxyConfigRequest) (*Empty, error)
	// Revision Management (E2E encrypted)
	PushRevision(context.Context, *PushRevisionRequest) (*PushRevisionResponse, error)
	GetRevision(context.Context, *GetRevisionRequest) (*GetRevisionResponse, error)
	ListRevisions(context.Context, *ListRevisionsRequest) (*ListRevisionsResponse, error)
	FlushRevisions(context.Context, *FlushRevisionsRequest) (*FlushRevisionsResponse, error)
	mustEmbedUnimplementedMobileServiceServer()
}

// UnimplementedMobileServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMobileServiceServer struct{}

func (UnimplementedMobileServiceServer) RegisterNodeViaCSR(context.Context, *RegisterNodeViaCSRRequest) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterNodeViaCSR not implemented")
}
func (UnimplementedMobileServiceServer) ListNodes(context.Context, *ListNodesRequest) (*ListNodesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListNodes not implemented")
}
func (UnimplementedMobileServiceServer) GetNode(context.Context, *GetNodeRequest) (*Node, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNode not implemented")
}
func (UnimplementedMobileServiceServer) RegisterNode(context.Context, *RegisterNodeRequest) (*RegisterNodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterNode not implemented")
}
func (UnimplementedMobileServiceServer) ApproveNode(context.Context, *ApproveNodeRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ApproveNode not implemented")
}
func (UnimplementedMobileServiceServer) DeleteNode(context.Context, *DeleteNodeRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteNode not implemented")
}
func (UnimplementedMobileServiceServer) SendCommand(context.Context, *CommandRequest) (*CommandResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendCommand not implemented")
}
func (UnimplementedMobileServiceServer) StreamMetrics(*StreamMetricsRequest, grpc.ServerStreamingServer[EncryptedMetrics]) error {
	return status.Error(codes.Unimplemented, "method StreamMetrics not implemented")
}
func (UnimplementedMobileServiceServer) GetMetricsHistory(context.Context, *GetMetricsHistoryRequest) (*GetMetricsHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMetricsHistory not implemented")
}
func (UnimplementedMobileServiceServer) StreamAlerts(*StreamAlertsRequest, grpc.ServerStreamingServer[common.Alert]) error {
	return status.Error(codes.Unimplemented, "method StreamAlerts not implemented")
}
func (UnimplementedMobileServiceServer) StreamSignaling(grpc.BidiStreamingServer[SignalMessage, SignalMessage]) error {
	return status.Error(codes.Unimplemented, "method StreamSignaling not implemented")
}
func (UnimplementedMobileServiceServer) CreateProxyConfig(context.Context, *CreateProxyConfigRequest) (*CreateProxyConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateProxyConfig not implemented")
}
func (UnimplementedMobileServiceServer) ListProxyConfigs(context.Context, *ListProxyConfigsRequest) (*ListProxyConfigsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListProxyConfigs not implemented")
}
func (UnimplementedMobileServiceServer) DeleteProxyConfig(context.Context, *DeleteProxyConfigRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteProxyConfig not implemented")
}
func (UnimplementedMobileServiceServer) PushRevision(context.Context, *PushRevisionRequest) (*PushRevisionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PushRevision not implemented")
}
func (UnimplementedMobileServiceServer) GetRevision(context.Context, *GetRevisionRequest) (*GetRevisionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRevision not implemented")
}
func (UnimplementedMobileServiceServer) ListRevisions(context.Context, *ListRevisionsRequest) (*ListRevisionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListRevisions not implemented")
}
func (UnimplementedMobileServiceServer) FlushRevisions(context.Context, *FlushRevisionsRequest) (*FlushRevisionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FlushRevisions not implemented")
}
func (UnimplementedMobileServiceServer) mustEmbedUnimplementedMobileServiceServer() {}
func (UnimplementedMobileServiceServer) testEmbeddedByValue()                       {}

// UnsafeMobileServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MobileServiceServer will
// result in compilation errors.
type UnsafeMobileServiceServer interface {
	mustEmbedUnimplementedMobileServiceServer()
}

func RegisterMobileServiceServer(s grpc.ServiceRegistrar, srv MobileServiceServer) {
	// If the following call panics, it indicates UnimplementedMobileServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MobileService_ServiceDesc, srv)
}

func _MobileService_RegisterNodeViaCSR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterNodeViaCSRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileServiceServer).RegisterNodeViaCSR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileService_RegisterNodeViaCSR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileServiceServer).RegisterNodeViaCSR(ctx, req.(*RegisterNodeViaCSRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileService_ListNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileServiceServer).ListNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileService_ListNodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileServiceServer).ListNodes(ctx, req.(*ListNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileService_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileServiceServer).GetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileService_GetNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileServiceServer).GetNode(ctx, req.(*GetNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileService_RegisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileServiceServer).RegisterNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileService_RegisterNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileServiceServer).RegisterNode(ctx, req.(*RegisterNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileService_ApproveNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileServiceServer).ApproveNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileService_ApproveNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileServiceServer).ApproveNode(ctx, req.(*ApproveNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileService_DeleteNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileServiceServer).DeleteNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileService_DeleteNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileServiceServer).DeleteNode(ctx, req.(*DeleteNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileService_SendCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileServiceServer).SendCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileService_SendCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileServiceServer).SendCommand(ctx, req.(*CommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileService_StreamMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamMetricsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MobileServiceServer).StreamMetrics(m, &grpc.GenericServerStream[StreamMetricsRequest, EncryptedMetrics]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MobileService_StreamMetricsServer = grpc.ServerStreamingServer[EncryptedMetrics]

func _MobileService_GetMetricsHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMetricsHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileServiceServer).GetMetricsHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileService_GetMetricsHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileServiceServer).GetMetricsHistory(ctx, req.(*GetMetricsHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileService_StreamAlerts_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamAlertsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MobileServiceServer).StreamAlerts(m, &grpc.GenericServerStream[StreamAlertsRequest, common.Alert]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MobileService_StreamAlertsServer = grpc.ServerStreamingServer[common.Alert]

func _MobileService_StreamSignaling_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MobileServiceServer).StreamSignaling(&grpc.GenericServerStream[SignalMessage, SignalMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MobileService_StreamSignalingServer = grpc.BidiStreamingServer[SignalMessage, SignalMessage]

func _MobileService_CreateProxyConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProxyConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileServiceServer).CreateProxyConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileService_CreateProxyConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileServiceServer).CreateProxyConfig(ctx, req.(*CreateProxyConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileService_ListProxyConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProxyConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileServiceServer).ListProxyConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileService_ListProxyConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileServiceServer).ListProxyConfigs(ctx, req.(*ListProxyConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileService_DeleteProxyConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProxyConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileServiceServer).DeleteProxyConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileService_DeleteProxyConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileServiceServer).DeleteProxyConfig(ctx, req.(*DeleteProxyConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileService_PushRevision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushRevisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileServiceServer).PushRevision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileService_PushRevision_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileServiceServer).PushRevision(ctx, req.(*PushRevisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileService_GetRevision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRevisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileServiceServer).GetRevision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileService_GetRevision_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileServiceServer).GetRevision(ctx, req.(*GetRevisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileService_ListRevisions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRevisionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileServiceServer).ListRevisions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileService_ListRevisions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileServiceServer).ListRevisions(ctx, req.(*ListRevisionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileService_FlushRevisions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlushRevisionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileServiceServer).FlushRevisions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileService_FlushRevisions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileServiceServer).FlushRevisions(ctx, req.(*FlushRevisionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MobileService_ServiceDesc is the grpc.ServiceDesc for MobileService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MobileService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nitella.hub.MobileService",
	HandlerType: (*MobileServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterNodeViaCSR",
			Handler:    _MobileService_RegisterNodeViaCSR_Handler,
		},
		{
			MethodName: "ListNodes",
			Handler:    _MobileService_ListNodes_Handler,
		},
		{
			MethodName: "GetNode",
			Handler:    _MobileService_GetNode_Handler,
		},
		{
			MethodName: "RegisterNode",
			Handler:    _MobileService_RegisterNode_Handler,
		},
		{
			MethodName: "ApproveNode",
			Handler:    _MobileService_ApproveNode_Handler,
		},
		{
			MethodName: "DeleteNode",
			Handler:    _MobileService_DeleteNode_Handler,
		},
		{
			MethodName: "SendCommand",
			Handler:    _MobileService_SendCommand_Handler,
		},
		{
			MethodName: "GetMetricsHistory",
			Handler:    _MobileService_GetMetricsHistory_Handler,
		},
		{
			MethodName: "CreateProxyConfig",
			Handler:    _MobileService_CreateProxyConfig_Handler,
		},
		{
			MethodName: "ListProxyConfigs",
			Handler:    _MobileService_ListProxyConfigs_Handler,
		},
		{
			MethodName: "DeleteProxyConfig",
			Handler:    _MobileService_DeleteProxyConfig_Handler,
		},
		{
			MethodName: "PushRevision",
			Handler:    _MobileService_PushRevision_Handler,
		},
		{
			MethodName: "GetRevision",
			Handler:    _MobileService_GetRevision_Handler,
		},
		{
			MethodName: "ListRevisions",
			Handler:    _MobileService_ListRevisions_Handler,
		},
		{
			MethodName: "FlushRevisions",
			Handler:    _MobileService_FlushRevisions_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamMetrics",
			Handler:       _MobileService_StreamMetrics_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamAlerts",
			Handler:       _MobileService_StreamAlerts_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamSignaling",
			Handler:       _MobileService_StreamSignaling_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "hub/hub_mobile.proto",
}

const (
	PairingService_PakeExchange_FullMethodName     = "/nitella.hub.PairingService/PakeExchange"
	PairingService_SubmitSignedCert_FullMethodName = "/nitella.hub.PairingService/SubmitSignedCert"
)

// PairingServiceClient is the client API for PairingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PairingServiceClient interface {
	// PAKE-based pairing: CLI and Node exchange encrypted messages via Hub
	// Hub only relays - cannot derive shared secret or decrypt payloads
	// Flow:
	//  1. CLI generates code "7-tiger-castle", starts PakeExchange
	//  2. User tells code to node (verbally or types)
	//  3. Node connects with same code, joins PakeExchange
	//  4. Both derive shared secret (Hub cannot compute)
	//  5. Node sends CSR encrypted with shared secret
	//  6. CLI signs CSR, sends cert encrypted with shared secret
	PakeExchange(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[PakeMessage, PakeMessage], error)
	// QR-based pairing (offline/air-gapped mode)
	// Node displays QR with CSR, user scans with CLI, CLI signs and displays cert QR
	// Hub not involved at all - fully offline
	SubmitSignedCert(ctx context.Context, in *SubmitSignedCertRequest, opts ...grpc.CallOption) (*Empty, error)
}

type pairingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPairingServiceClient(cc grpc.ClientConnInterface) PairingServiceClient {
	return &pairingServiceClient{cc}
}

func (c *pairingServiceClient) PakeExchange(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[PakeMessage, PakeMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PairingService_ServiceDesc.Streams[0], PairingService_PakeExchange_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[PakeMessage, PakeMessage]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PairingService_PakeExchangeClient = grpc.BidiStreamingClient[PakeMessage, PakeMessage]

func (c *pairingServiceClient) SubmitSignedCert(ctx context.Context, in *SubmitSignedCertRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, PairingService_SubmitSignedCert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PairingServiceServer is the server API for PairingService service.
// All implementations must embed UnimplementedPairingServiceServer
// for forward compatibility.
type PairingServiceServer interface {
	// PAKE-based pairing: CLI and Node exchange encrypted messages via Hub
	// Hub only relays - cannot derive shared secret or decrypt payloads
	// Flow:
	//  1. CLI generates code "7-tiger-castle", starts PakeExchange
	//  2. User tells code to node (verbally or types)
	//  3. Node connects with same code, joins PakeExchange
	//  4. Both derive shared secret (Hub cannot compute)
	//  5. Node sends CSR encrypted with shared secret
	//  6. CLI signs CSR, sends cert encrypted with shared secret
	PakeExchange(grpc.BidiStreamingServer[PakeMessage, PakeMessage]) error
	// QR-based pairing (offline/air-gapped mode)
	// Node displays QR with CSR, user scans with CLI, CLI signs and displays cert QR
	// Hub not involved at all - fully offline
	SubmitSignedCert(context.Context, *SubmitSignedCertRequest) (*Empty, error)
	mustEmbedUnimplementedPairingServiceServer()
}

// UnimplementedPairingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPairingServiceServer struct{}

func (UnimplementedPairingServiceServer) PakeExchange(grpc.BidiStreamingServer[PakeMessage, PakeMessage]) error {
	return status.Error(codes.Unimplemented, "method PakeExchange not implemented")
}
func (UnimplementedPairingServiceServer) SubmitSignedCert(context.Context, *SubmitSignedCertRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method SubmitSignedCert not implemented")
}
func (UnimplementedPairingServiceServer) mustEmbedUnimplementedPairingServiceServer() {}
func (UnimplementedPairingServiceServer) testEmbeddedByValue()                        {}

// UnsafePairingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PairingServiceServer will
// result in compilation errors.
type UnsafePairingServiceServer interface {
	mustEmbedUnimplementedPairingServiceServer()
}

func RegisterPairingServiceServer(s grpc.ServiceRegistrar, srv PairingServiceServer) {
	// If the following call panics, it indicates UnimplementedPairingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PairingService_ServiceDesc, srv)
}

func _PairingService_PakeExchange_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PairingServiceServer).PakeExchange(&grpc.GenericServerStream[PakeMessage, PakeMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PairingService_PakeExchangeServer = grpc.BidiStreamingServer[PakeMessage, PakeMessage]

func _PairingService_SubmitSignedCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitSignedCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PairingServiceServer).SubmitSignedCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PairingService_SubmitSignedCert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PairingServiceServer).SubmitSignedCert(ctx, req.(*SubmitSignedCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PairingService_ServiceDesc is the grpc.ServiceDesc for PairingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PairingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nitella.hub.PairingService",
	HandlerType: (*PairingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitSignedCert",
			Handler:    _PairingService_SubmitSignedCert_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PakeExchange",
			Handler:       _PairingService_PakeExchange_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "hub/hub_mobile.proto",
}

const (
	AuthService_RegisterUser_FullMethodName   = "/nitella.hub.AuthService/RegisterUser"
	AuthService_RegisterDevice_FullMethodName = "/nitella.hub.AuthService/RegisterDevice"
	AuthService_UpdateLicense_FullMethodName  = "/nitella.hub.AuthService/UpdateLicense"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthServiceClient interface {
	RegisterUser(ctx context.Context, in *RegisterUserRequest, opts ...grpc.CallOption) (*RegisterUserResponse, error)
	RegisterDevice(ctx context.Context, in *RegisterDeviceRequest, opts ...grpc.CallOption) (*Empty, error)
	UpdateLicense(ctx context.Context, in *UpdateLicenseRequest, opts ...grpc.CallOption) (*UpdateLicenseResponse, error)
}

type authServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) RegisterUser(ctx context.Context, in *RegisterUserRequest, opts ...grpc.CallOption) (*RegisterUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterUserResponse)
	err := c.cc.Invoke(ctx, AuthService_RegisterUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) RegisterDevice(ctx context.Context, in *RegisterDeviceRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AuthService_RegisterDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdateLicense(ctx context.Context, in *UpdateLicenseRequest, opts ...grpc.CallOption) (*UpdateLicenseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateLicenseResponse)
	err := c.cc.Invoke(ctx, AuthService_UpdateLicense_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility.
type AuthServiceServer interface {
	RegisterUser(context.Context, *RegisterUserRequest) (*RegisterUserResponse, error)
	RegisterDevice(context.Context, *RegisterDeviceRequest) (*Empty, error)
	UpdateLicense(context.Context, *UpdateLicenseRequest) (*UpdateLicenseResponse, error)
	mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServiceServer struct{}

func (UnimplementedAuthServiceServer) RegisterUser(context.Context, *RegisterUserRequest) (*RegisterUserResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterUser not implemented")
}
func (UnimplementedAuthServiceServer) RegisterDevice(context.Context, *RegisterDeviceRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterDevice not implemented")
}
func (UnimplementedAuthServiceServer) UpdateLicense(context.Context, *UpdateLicenseRequest) (*UpdateLicenseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateLicense not implemented")
}
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {}
func (UnimplementedAuthServiceServer) testEmbeddedByValue()                     {}

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
	mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) {
	// If the following call panics, it indicates UnimplementedAuthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuthService_ServiceDesc, srv)
}

func _AuthService_RegisterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).RegisterUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_RegisterUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).RegisterUser(ctx, req.(*RegisterUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_RegisterDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).RegisterDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_RegisterDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).RegisterDevice(ctx, req.(*RegisterDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateLicense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLicenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateLicense(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_UpdateLicense_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateLicense(ctx, req.(*UpdateLicenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nitella.hub.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterUser",
			Handler:    _AuthService_RegisterUser_Handler,
		},
		{
			MethodName: "RegisterDevice",
			Handler:    _AuthService_RegisterDevice_Handler,
		},
		{
			MethodName: "UpdateLicense",
			Handler:    _AuthService_UpdateLicense_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hub/hub_mobile.proto",
}
