// Code generated by protoc-gen-synurang-ffi. DO NOT EDIT.

package process

/*
#include <stdlib.h>
*/
import "C"

import (
	"context"
	"fmt"
	"unsafe"

	"github.com/ivere27/synurang/pkg/synurang"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/proto"
)

// =============================================================================
// FFI Server Interface
// =============================================================================

type FfiServer interface {
	ProcessControlServer
	StreamEventsInternal(context.Context, *StreamEventsRequest) (*Event, error)
}

// =============================================================================
// Invoke - returns []byte (for TCP/UDS)
// =============================================================================

func Invoke(s FfiServer, ctx context.Context, method string, data []byte) ([]byte, error) {
	switch method {
	case "/nitella.process.ProcessControl/StartListener":
		req := &StartListenerRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.StartListener(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.process.ProcessControl/StopListener":
		req := &StopListenerRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.StopListener(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.process.ProcessControl/HealthCheck":
		req := &HealthCheckRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.HealthCheck(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.process.ProcessControl/GetMetrics":
		req := &GetMetricsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetMetrics(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.process.ProcessControl/AddRule":
		req := &AddRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.AddRule(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.process.ProcessControl/RemoveRule":
		req := &RemoveRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RemoveRule(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.process.ProcessControl/ListRules":
		req := &ListRulesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListRules(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.process.ProcessControl/GetActiveConnections":
		req := &GetActiveConnectionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetActiveConnections(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.process.ProcessControl/CloseConnection":
		req := &CloseConnectionRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CloseConnection(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.process.ProcessControl/CloseAllConnections":
		req := &CloseAllConnectionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CloseAllConnections(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.process.ProcessControl/StreamEvents":
		req := &StreamEventsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.StreamEventsInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	default:
		return nil, fmt.Errorf("unknown method: %s", method)
	}
}

// =============================================================================
// InvokeFfi - returns C pointer (for zero-copy FFI)
// =============================================================================

// InvokeFfi is the zero-copy variant for FFI mode.
// It allocates C memory and serializes directly into it.
// Caller is responsible for freeing the returned pointer via C.free().
func InvokeFfi(s FfiServer, ctx context.Context, method string, data []byte) (unsafe.Pointer, int64, error) {
	switch method {
	case "/nitella.process.ProcessControl/StartListener":
		req := &StartListenerRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.StartListener(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.process.ProcessControl/StopListener":
		req := &StopListenerRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.StopListener(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.process.ProcessControl/HealthCheck":
		req := &HealthCheckRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.HealthCheck(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.process.ProcessControl/GetMetrics":
		req := &GetMetricsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetMetrics(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.process.ProcessControl/AddRule":
		req := &AddRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.AddRule(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.process.ProcessControl/RemoveRule":
		req := &RemoveRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RemoveRule(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.process.ProcessControl/ListRules":
		req := &ListRulesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListRules(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.process.ProcessControl/GetActiveConnections":
		req := &GetActiveConnectionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetActiveConnections(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.process.ProcessControl/CloseConnection":
		req := &CloseConnectionRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CloseConnection(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.process.ProcessControl/CloseAllConnections":
		req := &CloseAllConnectionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CloseAllConnections(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.process.ProcessControl/StreamEvents":
		req := &StreamEventsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.StreamEventsInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	default:
		return nil, 0, fmt.Errorf("unknown method: %s", method)
	}
}

// =============================================================================
// InvokeStream - dispatches streaming RPC calls
// =============================================================================

func InvokeStream(s FfiServer, ctx context.Context, method string, stream grpc.ServerStream) error {
	switch method {
	case "/nitella.process.ProcessControl/StreamEvents":
		req := &StreamEventsRequest{}
		if err := stream.RecvMsg(req); err != nil {
			return err
		}
		return s.StreamEvents(req, &grpcProcessControlStreamEventsStream{stream})
	default:
		return fmt.Errorf("unknown streaming method: %s", method)
	}
}

// =============================================================================
// gRPC Stream Wrappers
// =============================================================================

type grpcProcessControlStreamEventsStream struct {
	grpc.ServerStream
}

func (s *grpcProcessControlStreamEventsStream) Send(m *Event) error {
	return s.ServerStream.SendMsg(m)
}

var _ ProcessControl_StreamEventsServer = (*grpcProcessControlStreamEventsStream)(nil)

// =============================================================================
// FFI Invoker - wraps FfiServer to implement synurang.Invoker interface
// =============================================================================

// ffiInvoker wraps FfiServer to implement the synurang.Invoker interface.
// This allows using the synurang runtime's FfiClientConn with generated code.
// Uses zero-copy: proto.Message pointers are passed directly without serialization.
type ffiInvoker struct {
	server FfiServer
}

// Invoke implements synurang.UnaryInvoker (zero-copy).
func (i *ffiInvoker) Invoke(ctx context.Context, method string, req, reply proto.Message) error {
	switch method {
	case "/nitella.process.ProcessControl/StartListener":
		resp, err := i.server.StartListener(ctx, req.(*StartListenerRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.process.ProcessControl/StopListener":
		resp, err := i.server.StopListener(ctx, req.(*StopListenerRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.process.ProcessControl/HealthCheck":
		resp, err := i.server.HealthCheck(ctx, req.(*HealthCheckRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.process.ProcessControl/GetMetrics":
		resp, err := i.server.GetMetrics(ctx, req.(*GetMetricsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.process.ProcessControl/AddRule":
		resp, err := i.server.AddRule(ctx, req.(*AddRuleRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.process.ProcessControl/RemoveRule":
		resp, err := i.server.RemoveRule(ctx, req.(*RemoveRuleRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.process.ProcessControl/ListRules":
		resp, err := i.server.ListRules(ctx, req.(*ListRulesRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.process.ProcessControl/GetActiveConnections":
		resp, err := i.server.GetActiveConnections(ctx, req.(*GetActiveConnectionsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.process.ProcessControl/CloseConnection":
		resp, err := i.server.CloseConnection(ctx, req.(*CloseConnectionRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.process.ProcessControl/CloseAllConnections":
		resp, err := i.server.CloseAllConnections(ctx, req.(*CloseAllConnectionsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.process.ProcessControl/StreamEvents":
		resp, err := i.server.StreamEventsInternal(ctx, req.(*StreamEventsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	default:
		return fmt.Errorf("unknown method: %s", method)
	}
}

// InvokeStream implements synurang.StreamInvoker (zero-copy).
func (i *ffiInvoker) InvokeStream(ctx context.Context, method string, stream synurang.ServerStream) error {
	switch method {
	case "/nitella.process.ProcessControl/StreamEvents":
		// Server streaming (zero-copy)
		reqMsg, err := stream.RecvMsgDirect()
		if err != nil {
			return err
		}
		req := reqMsg.(*StreamEventsRequest)
		return i.server.StreamEvents(req, &ffiProcessControlStreamEventsStream{stream})
	default:
		return fmt.Errorf("unknown streaming method: %s", method)
	}
}

// =============================================================================
// Stream Wrappers (zero-copy)
// =============================================================================

// ffiProcessControlStreamEventsStream wraps ServerStream for zero-copy ProcessControl.StreamEvents
type ffiProcessControlStreamEventsStream struct {
	synurang.ServerStream
}

func (s *ffiProcessControlStreamEventsStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiProcessControlStreamEventsStream) Send(m *Event) error {
	return s.ServerStream.SendMsg(m)
}

var _ ProcessControl_StreamEventsServer = (*ffiProcessControlStreamEventsStream)(nil)

var _ synurang.Invoker = (*ffiInvoker)(nil)

// =============================================================================
// FFI Client - convenience wrapper for synurang.FfiClientConn
// =============================================================================

func NewFfiClientConn(server FfiServer) grpc.ClientConnInterface {
	return synurang.NewFfiClientConn(&ffiInvoker{server: server})
}
