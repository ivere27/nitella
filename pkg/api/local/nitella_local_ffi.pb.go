// Code generated by protoc-gen-synurang-ffi. DO NOT EDIT.

package local

/*
#include <stdlib.h>
*/
import "C"

import (
	"context"
	"fmt"
	"unsafe"

	"github.com/ivere27/synurang/pkg/synurang"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
)

// =============================================================================
// FFI Server Interface
// =============================================================================

type FfiServer interface {
	MobileLogicServiceServer
	StreamApprovalsInternal(context.Context, *StreamApprovalsRequest) (*ApprovalRequest, error)
	StreamConnectionsInternal(context.Context, *StreamConnectionsRequest) (*ConnectionEvent, error)
	StreamP2PStatusInternal(context.Context, *empty.Empty) (*P2PStatus, error)
	StreamMetricsInternal(context.Context, *StreamMetricsRequest) (*NodeMetrics, error)
}

// =============================================================================
// Invoke - returns []byte (for TCP/UDS)
// =============================================================================

func Invoke(s FfiServer, ctx context.Context, method string, data []byte) ([]byte, error) {
	switch method {
	case "/nitella.local.MobileLogicService/Initialize":
		req := &InitializeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Initialize(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/Shutdown":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Shutdown(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetBootstrapState":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetBootstrapState(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetIdentity":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetIdentity(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/CreateIdentity":
		req := &CreateIdentityRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CreateIdentity(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/RestoreIdentity":
		req := &RestoreIdentityRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RestoreIdentity(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ImportIdentity":
		req := &ImportIdentityRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ImportIdentity(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/UnlockIdentity":
		req := &UnlockIdentityRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.UnlockIdentity(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/LockIdentity":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.LockIdentity(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ChangePassphrase":
		req := &ChangePassphraseRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ChangePassphrase(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/EvaluatePassphrase":
		req := &EvaluatePassphraseRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.EvaluatePassphrase(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ResetIdentity":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ResetIdentity(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ListNodes":
		req := &ListNodesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListNodes(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetNode":
		req := &GetNodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetNode(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetNodeDetailSnapshot":
		req := &GetNodeDetailSnapshotRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetNodeDetailSnapshot(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/UpdateNode":
		req := &UpdateNodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.UpdateNode(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/RemoveNode":
		req := &RemoveNodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RemoveNode(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/AddNodeDirect":
		req := &AddNodeDirectRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.AddNodeDirect(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/TestDirectConnection":
		req := &TestDirectConnectionRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.TestDirectConnection(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ListProxies":
		req := &ListProxiesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListProxies(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetProxiesSnapshot":
		req := &GetProxiesSnapshotRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetProxiesSnapshot(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetProxy":
		req := &GetProxyRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetProxy(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/AddProxy":
		req := &AddProxyRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.AddProxy(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/UpdateProxy":
		req := &UpdateProxyRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.UpdateProxy(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/SetNodeProxiesRunning":
		req := &SetNodeProxiesRunningRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.SetNodeProxiesRunning(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/RemoveProxy":
		req := &RemoveProxyRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RemoveProxy(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ListRules":
		req := &ListRulesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListRules(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetRule":
		req := &GetRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetRule(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/AddRule":
		req := &AddRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.AddRule(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/AddQuickRule":
		req := &AddQuickRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.AddQuickRule(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/UpdateRule":
		req := &UpdateRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.UpdateRule(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/RemoveRule":
		req := &RemoveRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RemoveRule(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/BlockIP":
		req := &BlockIPRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.BlockIP(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/BlockISP":
		req := &BlockISPRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.BlockISP(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/BlockCountry":
		req := &BlockCountryRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.BlockCountry(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/AddGlobalRule":
		req := &AddGlobalRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.AddGlobalRule(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ListGlobalRules":
		req := &ListGlobalRulesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListGlobalRules(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/RemoveGlobalRule":
		req := &RemoveGlobalRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RemoveGlobalRule(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ListPendingApprovals":
		req := &ListPendingApprovalsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListPendingApprovals(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetApprovalsSnapshot":
		req := &GetApprovalsSnapshotRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetApprovalsSnapshot(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ApproveRequest":
		req := &ApproveRequestRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ApproveRequest(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/DenyRequest":
		req := &DenyRequestRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DenyRequest(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ResolveApprovalDecision":
		req := &ResolveApprovalDecisionRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ResolveApprovalDecision(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/StreamApprovals":
		req := &StreamApprovalsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.StreamApprovalsInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ListApprovalHistory":
		req := &ListApprovalHistoryRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListApprovalHistory(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ClearApprovalHistory":
		req := &ClearApprovalHistoryRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ClearApprovalHistory(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetConnectionStats":
		req := &GetConnectionStatsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetConnectionStats(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ListConnections":
		req := &ListConnectionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListConnections(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetIPStats":
		req := &GetIPStatsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetIPStats(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetGeoStats":
		req := &GetGeoStatsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetGeoStats(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/StreamConnections":
		req := &StreamConnectionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.StreamConnectionsInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/CloseConnection":
		req := &CloseConnectionRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CloseConnection(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/CloseAllConnections":
		req := &CloseAllConnectionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CloseAllConnections(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/CloseAllNodeConnections":
		req := &CloseAllNodeConnectionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CloseAllNodeConnections(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/StartPairing":
		req := &StartPairingRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.StartPairing(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/JoinPairing":
		req := &JoinPairingRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.JoinPairing(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/CompletePairing":
		req := &CompletePairingRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CompletePairing(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/FinalizePairing":
		req := &FinalizePairingRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.FinalizePairing(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/CancelPairing":
		req := &CancelPairingRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CancelPairing(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GenerateQRCode":
		req := &GenerateQRCodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GenerateQRCode(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ScanQRCode":
		req := &ScanQRCodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ScanQRCode(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GenerateQRResponse":
		req := &GenerateQRReplyRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GenerateQRResponse(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ListTemplates":
		req := &ListTemplatesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListTemplates(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetTemplate":
		req := &GetTemplateRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetTemplate(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/CreateTemplate":
		req := &CreateTemplateRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CreateTemplate(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ApplyTemplate":
		req := &ApplyTemplateRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ApplyTemplate(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/DeleteTemplate":
		req := &DeleteTemplateRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DeleteTemplate(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/SyncTemplates":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.SyncTemplates(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ExportTemplateYaml":
		req := &ExportTemplateYamlRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ExportTemplateYaml(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ImportTemplateYaml":
		req := &ImportTemplateYamlRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ImportTemplateYaml(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetSettings":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetSettings(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetSettingsOverviewSnapshot":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetSettingsOverviewSnapshot(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/UpdateSettings":
		req := &UpdateSettingsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.UpdateSettings(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/RegisterFCMToken":
		req := &RegisterFCMTokenRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RegisterFCMToken(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/UnregisterFCMToken":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.UnregisterFCMToken(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ConnectToHub":
		req := &ConnectToHubRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ConnectToHub(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/DisconnectFromHub":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DisconnectFromHub(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetHubStatus":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetHubStatus(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetHubSettingsSnapshot":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetHubSettingsSnapshot(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetHubOverview":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetHubOverview(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetHubDashboardSnapshot":
		req := &GetHubDashboardSnapshotRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetHubDashboardSnapshot(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/RegisterUser":
		req := &RegisterUserRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RegisterUser(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/FetchHubCA":
		req := &FetchHubCARequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.FetchHubCA(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/OnboardHub":
		req := &OnboardHubRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.OnboardHub(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/EnsureHubConnected":
		req := &EnsureHubConnectedRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.EnsureHubConnected(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/EnsureHubRegistered":
		req := &EnsureHubRegisteredRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.EnsureHubRegistered(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ResolveHubTrustChallenge":
		req := &ResolveHubTrustChallengeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ResolveHubTrustChallenge(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetP2PStatus":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetP2PStatus(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetP2PSettingsSnapshot":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetP2PSettingsSnapshot(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/StreamP2PStatus":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.StreamP2PStatusInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/SetP2PMode":
		req := &SetP2PModeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.SetP2PMode(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/LookupIP":
		req := &LookupIPRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.LookupIP(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ConfigureGeoIP":
		req := &ConfigureGeoIPNodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ConfigureGeoIP(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetGeoIPStatus":
		req := &GetGeoIPStatusNodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetGeoIPStatus(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/RestartListeners":
		req := &RestartListenersNodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RestartListeners(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ListLocalProxyConfigs":
		req := &ListLocalProxyConfigsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListLocalProxyConfigs(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetLocalProxyConfig":
		req := &GetLocalProxyConfigRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetLocalProxyConfig(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ImportLocalProxyConfig":
		req := &ImportLocalProxyConfigRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ImportLocalProxyConfig(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/SaveLocalProxyConfig":
		req := &SaveLocalProxyConfigRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.SaveLocalProxyConfig(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/DeleteLocalProxyConfig":
		req := &DeleteLocalProxyConfigRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DeleteLocalProxyConfig(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ValidateLocalProxyConfig":
		req := &ValidateLocalProxyConfigRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ValidateLocalProxyConfig(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/PushProxyRevision":
		req := &PushProxyRevisionRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.PushProxyRevision(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/PushLocalProxyRevision":
		req := &PushLocalProxyRevisionRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.PushLocalProxyRevision(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/PullProxyRevision":
		req := &PullProxyRevisionRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.PullProxyRevision(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/DiffProxyRevisions":
		req := &DiffProxyRevisionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DiffProxyRevisions(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ListProxyRevisions":
		req := &ListProxyRevisionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListProxyRevisions(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/FlushProxyRevisions":
		req := &FlushProxyRevisionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.FlushProxyRevisions(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ListProxyConfigs":
		req := &ListProxyConfigsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListProxyConfigs(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/CreateProxyConfig":
		req := &CreateProxyConfigRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CreateProxyConfig(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/DeleteProxyConfig":
		req := &DeleteProxyConfigRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DeleteProxyConfig(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ApplyProxyToNode":
		req := &ApplyProxyToNodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ApplyProxyToNode(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/UnapplyProxyFromNode":
		req := &UnapplyProxyFromNodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.UnapplyProxyFromNode(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetAppliedProxies":
		req := &GetAppliedProxiesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetAppliedProxies(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/AllowIP":
		req := &AllowIPRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.AllowIP(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/StreamMetrics":
		req := &StreamMetricsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.StreamMetricsInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetDebugRuntimeStats":
		req := &GetDebugRuntimeStatsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetDebugRuntimeStats(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetLogsStats":
		req := &GetLogsStatsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetLogsStats(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/ListLogs":
		req := &ListLogsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListLogs(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/DeleteLogs":
		req := &DeleteLogsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DeleteLogs(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/CleanupOldLogs":
		req := &CleanupOldLogsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CleanupOldLogs(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/GetNodeFromHub":
		req := &GetNodeFromHubRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetNodeFromHub(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/nitella.local.MobileLogicService/RegisterNodeWithHub":
		req := &RegisterNodeWithHubRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RegisterNodeWithHub(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	default:
		return nil, fmt.Errorf("unknown method: %s", method)
	}
}

// =============================================================================
// InvokeFfi - returns C pointer (for zero-copy FFI)
// =============================================================================

// InvokeFfi is the zero-copy variant for FFI mode.
// It allocates C memory and serializes directly into it.
// Caller is responsible for freeing the returned pointer via C.free().
func InvokeFfi(s FfiServer, ctx context.Context, method string, data []byte) (unsafe.Pointer, int64, error) {
	switch method {
	case "/nitella.local.MobileLogicService/Initialize":
		req := &InitializeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Initialize(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/Shutdown":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Shutdown(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetBootstrapState":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetBootstrapState(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetIdentity":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetIdentity(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/CreateIdentity":
		req := &CreateIdentityRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CreateIdentity(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/RestoreIdentity":
		req := &RestoreIdentityRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RestoreIdentity(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ImportIdentity":
		req := &ImportIdentityRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ImportIdentity(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/UnlockIdentity":
		req := &UnlockIdentityRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.UnlockIdentity(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/LockIdentity":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.LockIdentity(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ChangePassphrase":
		req := &ChangePassphraseRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ChangePassphrase(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/EvaluatePassphrase":
		req := &EvaluatePassphraseRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.EvaluatePassphrase(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ResetIdentity":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ResetIdentity(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ListNodes":
		req := &ListNodesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListNodes(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetNode":
		req := &GetNodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetNode(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetNodeDetailSnapshot":
		req := &GetNodeDetailSnapshotRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetNodeDetailSnapshot(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/UpdateNode":
		req := &UpdateNodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.UpdateNode(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/RemoveNode":
		req := &RemoveNodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RemoveNode(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/AddNodeDirect":
		req := &AddNodeDirectRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.AddNodeDirect(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/TestDirectConnection":
		req := &TestDirectConnectionRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.TestDirectConnection(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ListProxies":
		req := &ListProxiesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListProxies(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetProxiesSnapshot":
		req := &GetProxiesSnapshotRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetProxiesSnapshot(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetProxy":
		req := &GetProxyRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetProxy(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/AddProxy":
		req := &AddProxyRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.AddProxy(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/UpdateProxy":
		req := &UpdateProxyRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.UpdateProxy(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/SetNodeProxiesRunning":
		req := &SetNodeProxiesRunningRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.SetNodeProxiesRunning(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/RemoveProxy":
		req := &RemoveProxyRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RemoveProxy(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ListRules":
		req := &ListRulesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListRules(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetRule":
		req := &GetRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetRule(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/AddRule":
		req := &AddRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.AddRule(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/AddQuickRule":
		req := &AddQuickRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.AddQuickRule(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/UpdateRule":
		req := &UpdateRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.UpdateRule(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/RemoveRule":
		req := &RemoveRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RemoveRule(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/BlockIP":
		req := &BlockIPRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.BlockIP(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/BlockISP":
		req := &BlockISPRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.BlockISP(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/BlockCountry":
		req := &BlockCountryRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.BlockCountry(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/AddGlobalRule":
		req := &AddGlobalRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.AddGlobalRule(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ListGlobalRules":
		req := &ListGlobalRulesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListGlobalRules(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/RemoveGlobalRule":
		req := &RemoveGlobalRuleRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RemoveGlobalRule(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ListPendingApprovals":
		req := &ListPendingApprovalsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListPendingApprovals(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetApprovalsSnapshot":
		req := &GetApprovalsSnapshotRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetApprovalsSnapshot(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ApproveRequest":
		req := &ApproveRequestRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ApproveRequest(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/DenyRequest":
		req := &DenyRequestRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DenyRequest(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ResolveApprovalDecision":
		req := &ResolveApprovalDecisionRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ResolveApprovalDecision(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/StreamApprovals":
		req := &StreamApprovalsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.StreamApprovalsInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ListApprovalHistory":
		req := &ListApprovalHistoryRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListApprovalHistory(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ClearApprovalHistory":
		req := &ClearApprovalHistoryRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ClearApprovalHistory(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetConnectionStats":
		req := &GetConnectionStatsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetConnectionStats(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ListConnections":
		req := &ListConnectionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListConnections(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetIPStats":
		req := &GetIPStatsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetIPStats(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetGeoStats":
		req := &GetGeoStatsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetGeoStats(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/StreamConnections":
		req := &StreamConnectionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.StreamConnectionsInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/CloseConnection":
		req := &CloseConnectionRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CloseConnection(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/CloseAllConnections":
		req := &CloseAllConnectionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CloseAllConnections(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/CloseAllNodeConnections":
		req := &CloseAllNodeConnectionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CloseAllNodeConnections(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/StartPairing":
		req := &StartPairingRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.StartPairing(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/JoinPairing":
		req := &JoinPairingRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.JoinPairing(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/CompletePairing":
		req := &CompletePairingRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CompletePairing(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/FinalizePairing":
		req := &FinalizePairingRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.FinalizePairing(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/CancelPairing":
		req := &CancelPairingRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CancelPairing(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GenerateQRCode":
		req := &GenerateQRCodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GenerateQRCode(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ScanQRCode":
		req := &ScanQRCodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ScanQRCode(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GenerateQRResponse":
		req := &GenerateQRReplyRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GenerateQRResponse(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ListTemplates":
		req := &ListTemplatesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListTemplates(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetTemplate":
		req := &GetTemplateRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetTemplate(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/CreateTemplate":
		req := &CreateTemplateRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CreateTemplate(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ApplyTemplate":
		req := &ApplyTemplateRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ApplyTemplate(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/DeleteTemplate":
		req := &DeleteTemplateRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DeleteTemplate(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/SyncTemplates":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.SyncTemplates(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ExportTemplateYaml":
		req := &ExportTemplateYamlRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ExportTemplateYaml(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ImportTemplateYaml":
		req := &ImportTemplateYamlRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ImportTemplateYaml(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetSettings":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetSettings(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetSettingsOverviewSnapshot":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetSettingsOverviewSnapshot(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/UpdateSettings":
		req := &UpdateSettingsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.UpdateSettings(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/RegisterFCMToken":
		req := &RegisterFCMTokenRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RegisterFCMToken(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/UnregisterFCMToken":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.UnregisterFCMToken(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ConnectToHub":
		req := &ConnectToHubRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ConnectToHub(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/DisconnectFromHub":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DisconnectFromHub(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetHubStatus":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetHubStatus(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetHubSettingsSnapshot":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetHubSettingsSnapshot(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetHubOverview":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetHubOverview(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetHubDashboardSnapshot":
		req := &GetHubDashboardSnapshotRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetHubDashboardSnapshot(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/RegisterUser":
		req := &RegisterUserRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RegisterUser(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/FetchHubCA":
		req := &FetchHubCARequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.FetchHubCA(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/OnboardHub":
		req := &OnboardHubRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.OnboardHub(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/EnsureHubConnected":
		req := &EnsureHubConnectedRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.EnsureHubConnected(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/EnsureHubRegistered":
		req := &EnsureHubRegisteredRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.EnsureHubRegistered(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ResolveHubTrustChallenge":
		req := &ResolveHubTrustChallengeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ResolveHubTrustChallenge(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetP2PStatus":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetP2PStatus(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetP2PSettingsSnapshot":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetP2PSettingsSnapshot(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/StreamP2PStatus":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.StreamP2PStatusInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/SetP2PMode":
		req := &SetP2PModeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.SetP2PMode(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/LookupIP":
		req := &LookupIPRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.LookupIP(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ConfigureGeoIP":
		req := &ConfigureGeoIPNodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ConfigureGeoIP(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetGeoIPStatus":
		req := &GetGeoIPStatusNodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetGeoIPStatus(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/RestartListeners":
		req := &RestartListenersNodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RestartListeners(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ListLocalProxyConfigs":
		req := &ListLocalProxyConfigsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListLocalProxyConfigs(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetLocalProxyConfig":
		req := &GetLocalProxyConfigRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetLocalProxyConfig(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ImportLocalProxyConfig":
		req := &ImportLocalProxyConfigRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ImportLocalProxyConfig(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/SaveLocalProxyConfig":
		req := &SaveLocalProxyConfigRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.SaveLocalProxyConfig(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/DeleteLocalProxyConfig":
		req := &DeleteLocalProxyConfigRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DeleteLocalProxyConfig(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ValidateLocalProxyConfig":
		req := &ValidateLocalProxyConfigRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ValidateLocalProxyConfig(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/PushProxyRevision":
		req := &PushProxyRevisionRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.PushProxyRevision(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/PushLocalProxyRevision":
		req := &PushLocalProxyRevisionRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.PushLocalProxyRevision(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/PullProxyRevision":
		req := &PullProxyRevisionRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.PullProxyRevision(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/DiffProxyRevisions":
		req := &DiffProxyRevisionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DiffProxyRevisions(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ListProxyRevisions":
		req := &ListProxyRevisionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListProxyRevisions(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/FlushProxyRevisions":
		req := &FlushProxyRevisionsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.FlushProxyRevisions(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ListProxyConfigs":
		req := &ListProxyConfigsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListProxyConfigs(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/CreateProxyConfig":
		req := &CreateProxyConfigRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CreateProxyConfig(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/DeleteProxyConfig":
		req := &DeleteProxyConfigRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DeleteProxyConfig(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ApplyProxyToNode":
		req := &ApplyProxyToNodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ApplyProxyToNode(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/UnapplyProxyFromNode":
		req := &UnapplyProxyFromNodeRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.UnapplyProxyFromNode(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetAppliedProxies":
		req := &GetAppliedProxiesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetAppliedProxies(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/AllowIP":
		req := &AllowIPRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.AllowIP(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/StreamMetrics":
		req := &StreamMetricsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.StreamMetricsInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetDebugRuntimeStats":
		req := &GetDebugRuntimeStatsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetDebugRuntimeStats(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetLogsStats":
		req := &GetLogsStatsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetLogsStats(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/ListLogs":
		req := &ListLogsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.ListLogs(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/DeleteLogs":
		req := &DeleteLogsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DeleteLogs(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/CleanupOldLogs":
		req := &CleanupOldLogsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.CleanupOldLogs(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/GetNodeFromHub":
		req := &GetNodeFromHubRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetNodeFromHub(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/nitella.local.MobileLogicService/RegisterNodeWithHub":
		req := &RegisterNodeWithHubRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.RegisterNodeWithHub(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	default:
		return nil, 0, fmt.Errorf("unknown method: %s", method)
	}
}

// =============================================================================
// InvokeStream - dispatches streaming RPC calls
// =============================================================================

func InvokeStream(s FfiServer, ctx context.Context, method string, stream grpc.ServerStream) error {
	switch method {
	case "/nitella.local.MobileLogicService/StreamApprovals":
		req := &StreamApprovalsRequest{}
		if err := stream.RecvMsg(req); err != nil {
			return err
		}
		return s.StreamApprovals(req, &grpcMobileLogicServiceStreamApprovalsStream{stream})
	case "/nitella.local.MobileLogicService/StreamConnections":
		req := &StreamConnectionsRequest{}
		if err := stream.RecvMsg(req); err != nil {
			return err
		}
		return s.StreamConnections(req, &grpcMobileLogicServiceStreamConnectionsStream{stream})
	case "/nitella.local.MobileLogicService/StreamP2PStatus":
		req := &empty.Empty{}
		if err := stream.RecvMsg(req); err != nil {
			return err
		}
		return s.StreamP2PStatus(req, &grpcMobileLogicServiceStreamP2PStatusStream{stream})
	case "/nitella.local.MobileLogicService/StreamMetrics":
		req := &StreamMetricsRequest{}
		if err := stream.RecvMsg(req); err != nil {
			return err
		}
		return s.StreamMetrics(req, &grpcMobileLogicServiceStreamMetricsStream{stream})
	default:
		return fmt.Errorf("unknown streaming method: %s", method)
	}
}

// =============================================================================
// gRPC Stream Wrappers
// =============================================================================

type grpcMobileLogicServiceStreamApprovalsStream struct {
	grpc.ServerStream
}

func (s *grpcMobileLogicServiceStreamApprovalsStream) Send(m *ApprovalRequest) error {
	return s.ServerStream.SendMsg(m)
}

var _ MobileLogicService_StreamApprovalsServer = (*grpcMobileLogicServiceStreamApprovalsStream)(nil)

type grpcMobileLogicServiceStreamConnectionsStream struct {
	grpc.ServerStream
}

func (s *grpcMobileLogicServiceStreamConnectionsStream) Send(m *ConnectionEvent) error {
	return s.ServerStream.SendMsg(m)
}

var _ MobileLogicService_StreamConnectionsServer = (*grpcMobileLogicServiceStreamConnectionsStream)(nil)

type grpcMobileLogicServiceStreamP2PStatusStream struct {
	grpc.ServerStream
}

func (s *grpcMobileLogicServiceStreamP2PStatusStream) Send(m *P2PStatus) error {
	return s.ServerStream.SendMsg(m)
}

var _ MobileLogicService_StreamP2PStatusServer = (*grpcMobileLogicServiceStreamP2PStatusStream)(nil)

type grpcMobileLogicServiceStreamMetricsStream struct {
	grpc.ServerStream
}

func (s *grpcMobileLogicServiceStreamMetricsStream) Send(m *NodeMetrics) error {
	return s.ServerStream.SendMsg(m)
}

var _ MobileLogicService_StreamMetricsServer = (*grpcMobileLogicServiceStreamMetricsStream)(nil)

// =============================================================================
// FFI Invoker - wraps FfiServer to implement synurang.Invoker interface
// =============================================================================

// ffiInvoker wraps FfiServer to implement the synurang.Invoker interface.
// This allows using the synurang runtime's FfiClientConn with generated code.
// Uses zero-copy: proto.Message pointers are passed directly without serialization.
type ffiInvoker struct {
	server FfiServer
}

// Invoke implements synurang.UnaryInvoker (zero-copy).
func (i *ffiInvoker) Invoke(ctx context.Context, method string, req, reply proto.Message) error {
	switch method {
	case "/nitella.local.MobileLogicService/Initialize":
		resp, err := i.server.Initialize(ctx, req.(*InitializeRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/Shutdown":
		resp, err := i.server.Shutdown(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetBootstrapState":
		resp, err := i.server.GetBootstrapState(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetIdentity":
		resp, err := i.server.GetIdentity(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/CreateIdentity":
		resp, err := i.server.CreateIdentity(ctx, req.(*CreateIdentityRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/RestoreIdentity":
		resp, err := i.server.RestoreIdentity(ctx, req.(*RestoreIdentityRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ImportIdentity":
		resp, err := i.server.ImportIdentity(ctx, req.(*ImportIdentityRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/UnlockIdentity":
		resp, err := i.server.UnlockIdentity(ctx, req.(*UnlockIdentityRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/LockIdentity":
		resp, err := i.server.LockIdentity(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ChangePassphrase":
		resp, err := i.server.ChangePassphrase(ctx, req.(*ChangePassphraseRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/EvaluatePassphrase":
		resp, err := i.server.EvaluatePassphrase(ctx, req.(*EvaluatePassphraseRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ResetIdentity":
		resp, err := i.server.ResetIdentity(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ListNodes":
		resp, err := i.server.ListNodes(ctx, req.(*ListNodesRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetNode":
		resp, err := i.server.GetNode(ctx, req.(*GetNodeRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetNodeDetailSnapshot":
		resp, err := i.server.GetNodeDetailSnapshot(ctx, req.(*GetNodeDetailSnapshotRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/UpdateNode":
		resp, err := i.server.UpdateNode(ctx, req.(*UpdateNodeRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/RemoveNode":
		resp, err := i.server.RemoveNode(ctx, req.(*RemoveNodeRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/AddNodeDirect":
		resp, err := i.server.AddNodeDirect(ctx, req.(*AddNodeDirectRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/TestDirectConnection":
		resp, err := i.server.TestDirectConnection(ctx, req.(*TestDirectConnectionRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ListProxies":
		resp, err := i.server.ListProxies(ctx, req.(*ListProxiesRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetProxiesSnapshot":
		resp, err := i.server.GetProxiesSnapshot(ctx, req.(*GetProxiesSnapshotRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetProxy":
		resp, err := i.server.GetProxy(ctx, req.(*GetProxyRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/AddProxy":
		resp, err := i.server.AddProxy(ctx, req.(*AddProxyRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/UpdateProxy":
		resp, err := i.server.UpdateProxy(ctx, req.(*UpdateProxyRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/SetNodeProxiesRunning":
		resp, err := i.server.SetNodeProxiesRunning(ctx, req.(*SetNodeProxiesRunningRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/RemoveProxy":
		resp, err := i.server.RemoveProxy(ctx, req.(*RemoveProxyRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ListRules":
		resp, err := i.server.ListRules(ctx, req.(*ListRulesRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetRule":
		resp, err := i.server.GetRule(ctx, req.(*GetRuleRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/AddRule":
		resp, err := i.server.AddRule(ctx, req.(*AddRuleRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/AddQuickRule":
		resp, err := i.server.AddQuickRule(ctx, req.(*AddQuickRuleRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/UpdateRule":
		resp, err := i.server.UpdateRule(ctx, req.(*UpdateRuleRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/RemoveRule":
		resp, err := i.server.RemoveRule(ctx, req.(*RemoveRuleRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/BlockIP":
		resp, err := i.server.BlockIP(ctx, req.(*BlockIPRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/BlockISP":
		resp, err := i.server.BlockISP(ctx, req.(*BlockISPRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/BlockCountry":
		resp, err := i.server.BlockCountry(ctx, req.(*BlockCountryRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/AddGlobalRule":
		resp, err := i.server.AddGlobalRule(ctx, req.(*AddGlobalRuleRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ListGlobalRules":
		resp, err := i.server.ListGlobalRules(ctx, req.(*ListGlobalRulesRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/RemoveGlobalRule":
		resp, err := i.server.RemoveGlobalRule(ctx, req.(*RemoveGlobalRuleRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ListPendingApprovals":
		resp, err := i.server.ListPendingApprovals(ctx, req.(*ListPendingApprovalsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetApprovalsSnapshot":
		resp, err := i.server.GetApprovalsSnapshot(ctx, req.(*GetApprovalsSnapshotRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ApproveRequest":
		resp, err := i.server.ApproveRequest(ctx, req.(*ApproveRequestRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/DenyRequest":
		resp, err := i.server.DenyRequest(ctx, req.(*DenyRequestRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ResolveApprovalDecision":
		resp, err := i.server.ResolveApprovalDecision(ctx, req.(*ResolveApprovalDecisionRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/StreamApprovals":
		resp, err := i.server.StreamApprovalsInternal(ctx, req.(*StreamApprovalsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ListApprovalHistory":
		resp, err := i.server.ListApprovalHistory(ctx, req.(*ListApprovalHistoryRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ClearApprovalHistory":
		resp, err := i.server.ClearApprovalHistory(ctx, req.(*ClearApprovalHistoryRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetConnectionStats":
		resp, err := i.server.GetConnectionStats(ctx, req.(*GetConnectionStatsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ListConnections":
		resp, err := i.server.ListConnections(ctx, req.(*ListConnectionsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetIPStats":
		resp, err := i.server.GetIPStats(ctx, req.(*GetIPStatsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetGeoStats":
		resp, err := i.server.GetGeoStats(ctx, req.(*GetGeoStatsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/StreamConnections":
		resp, err := i.server.StreamConnectionsInternal(ctx, req.(*StreamConnectionsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/CloseConnection":
		resp, err := i.server.CloseConnection(ctx, req.(*CloseConnectionRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/CloseAllConnections":
		resp, err := i.server.CloseAllConnections(ctx, req.(*CloseAllConnectionsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/CloseAllNodeConnections":
		resp, err := i.server.CloseAllNodeConnections(ctx, req.(*CloseAllNodeConnectionsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/StartPairing":
		resp, err := i.server.StartPairing(ctx, req.(*StartPairingRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/JoinPairing":
		resp, err := i.server.JoinPairing(ctx, req.(*JoinPairingRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/CompletePairing":
		resp, err := i.server.CompletePairing(ctx, req.(*CompletePairingRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/FinalizePairing":
		resp, err := i.server.FinalizePairing(ctx, req.(*FinalizePairingRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/CancelPairing":
		resp, err := i.server.CancelPairing(ctx, req.(*CancelPairingRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GenerateQRCode":
		resp, err := i.server.GenerateQRCode(ctx, req.(*GenerateQRCodeRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ScanQRCode":
		resp, err := i.server.ScanQRCode(ctx, req.(*ScanQRCodeRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GenerateQRResponse":
		resp, err := i.server.GenerateQRResponse(ctx, req.(*GenerateQRReplyRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ListTemplates":
		resp, err := i.server.ListTemplates(ctx, req.(*ListTemplatesRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetTemplate":
		resp, err := i.server.GetTemplate(ctx, req.(*GetTemplateRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/CreateTemplate":
		resp, err := i.server.CreateTemplate(ctx, req.(*CreateTemplateRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ApplyTemplate":
		resp, err := i.server.ApplyTemplate(ctx, req.(*ApplyTemplateRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/DeleteTemplate":
		resp, err := i.server.DeleteTemplate(ctx, req.(*DeleteTemplateRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/SyncTemplates":
		resp, err := i.server.SyncTemplates(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ExportTemplateYaml":
		resp, err := i.server.ExportTemplateYaml(ctx, req.(*ExportTemplateYamlRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ImportTemplateYaml":
		resp, err := i.server.ImportTemplateYaml(ctx, req.(*ImportTemplateYamlRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetSettings":
		resp, err := i.server.GetSettings(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetSettingsOverviewSnapshot":
		resp, err := i.server.GetSettingsOverviewSnapshot(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/UpdateSettings":
		resp, err := i.server.UpdateSettings(ctx, req.(*UpdateSettingsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/RegisterFCMToken":
		resp, err := i.server.RegisterFCMToken(ctx, req.(*RegisterFCMTokenRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/UnregisterFCMToken":
		resp, err := i.server.UnregisterFCMToken(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ConnectToHub":
		resp, err := i.server.ConnectToHub(ctx, req.(*ConnectToHubRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/DisconnectFromHub":
		resp, err := i.server.DisconnectFromHub(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetHubStatus":
		resp, err := i.server.GetHubStatus(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetHubSettingsSnapshot":
		resp, err := i.server.GetHubSettingsSnapshot(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetHubOverview":
		resp, err := i.server.GetHubOverview(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetHubDashboardSnapshot":
		resp, err := i.server.GetHubDashboardSnapshot(ctx, req.(*GetHubDashboardSnapshotRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/RegisterUser":
		resp, err := i.server.RegisterUser(ctx, req.(*RegisterUserRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/FetchHubCA":
		resp, err := i.server.FetchHubCA(ctx, req.(*FetchHubCARequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/OnboardHub":
		resp, err := i.server.OnboardHub(ctx, req.(*OnboardHubRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/EnsureHubConnected":
		resp, err := i.server.EnsureHubConnected(ctx, req.(*EnsureHubConnectedRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/EnsureHubRegistered":
		resp, err := i.server.EnsureHubRegistered(ctx, req.(*EnsureHubRegisteredRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ResolveHubTrustChallenge":
		resp, err := i.server.ResolveHubTrustChallenge(ctx, req.(*ResolveHubTrustChallengeRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetP2PStatus":
		resp, err := i.server.GetP2PStatus(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetP2PSettingsSnapshot":
		resp, err := i.server.GetP2PSettingsSnapshot(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/StreamP2PStatus":
		resp, err := i.server.StreamP2PStatusInternal(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/SetP2PMode":
		resp, err := i.server.SetP2PMode(ctx, req.(*SetP2PModeRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/LookupIP":
		resp, err := i.server.LookupIP(ctx, req.(*LookupIPRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ConfigureGeoIP":
		resp, err := i.server.ConfigureGeoIP(ctx, req.(*ConfigureGeoIPNodeRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetGeoIPStatus":
		resp, err := i.server.GetGeoIPStatus(ctx, req.(*GetGeoIPStatusNodeRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/RestartListeners":
		resp, err := i.server.RestartListeners(ctx, req.(*RestartListenersNodeRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ListLocalProxyConfigs":
		resp, err := i.server.ListLocalProxyConfigs(ctx, req.(*ListLocalProxyConfigsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetLocalProxyConfig":
		resp, err := i.server.GetLocalProxyConfig(ctx, req.(*GetLocalProxyConfigRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ImportLocalProxyConfig":
		resp, err := i.server.ImportLocalProxyConfig(ctx, req.(*ImportLocalProxyConfigRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/SaveLocalProxyConfig":
		resp, err := i.server.SaveLocalProxyConfig(ctx, req.(*SaveLocalProxyConfigRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/DeleteLocalProxyConfig":
		resp, err := i.server.DeleteLocalProxyConfig(ctx, req.(*DeleteLocalProxyConfigRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ValidateLocalProxyConfig":
		resp, err := i.server.ValidateLocalProxyConfig(ctx, req.(*ValidateLocalProxyConfigRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/PushProxyRevision":
		resp, err := i.server.PushProxyRevision(ctx, req.(*PushProxyRevisionRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/PushLocalProxyRevision":
		resp, err := i.server.PushLocalProxyRevision(ctx, req.(*PushLocalProxyRevisionRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/PullProxyRevision":
		resp, err := i.server.PullProxyRevision(ctx, req.(*PullProxyRevisionRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/DiffProxyRevisions":
		resp, err := i.server.DiffProxyRevisions(ctx, req.(*DiffProxyRevisionsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ListProxyRevisions":
		resp, err := i.server.ListProxyRevisions(ctx, req.(*ListProxyRevisionsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/FlushProxyRevisions":
		resp, err := i.server.FlushProxyRevisions(ctx, req.(*FlushProxyRevisionsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ListProxyConfigs":
		resp, err := i.server.ListProxyConfigs(ctx, req.(*ListProxyConfigsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/CreateProxyConfig":
		resp, err := i.server.CreateProxyConfig(ctx, req.(*CreateProxyConfigRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/DeleteProxyConfig":
		resp, err := i.server.DeleteProxyConfig(ctx, req.(*DeleteProxyConfigRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ApplyProxyToNode":
		resp, err := i.server.ApplyProxyToNode(ctx, req.(*ApplyProxyToNodeRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/UnapplyProxyFromNode":
		resp, err := i.server.UnapplyProxyFromNode(ctx, req.(*UnapplyProxyFromNodeRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetAppliedProxies":
		resp, err := i.server.GetAppliedProxies(ctx, req.(*GetAppliedProxiesRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/AllowIP":
		resp, err := i.server.AllowIP(ctx, req.(*AllowIPRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/StreamMetrics":
		resp, err := i.server.StreamMetricsInternal(ctx, req.(*StreamMetricsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetDebugRuntimeStats":
		resp, err := i.server.GetDebugRuntimeStats(ctx, req.(*GetDebugRuntimeStatsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetLogsStats":
		resp, err := i.server.GetLogsStats(ctx, req.(*GetLogsStatsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/ListLogs":
		resp, err := i.server.ListLogs(ctx, req.(*ListLogsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/DeleteLogs":
		resp, err := i.server.DeleteLogs(ctx, req.(*DeleteLogsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/CleanupOldLogs":
		resp, err := i.server.CleanupOldLogs(ctx, req.(*CleanupOldLogsRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/GetNodeFromHub":
		resp, err := i.server.GetNodeFromHub(ctx, req.(*GetNodeFromHubRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/nitella.local.MobileLogicService/RegisterNodeWithHub":
		resp, err := i.server.RegisterNodeWithHub(ctx, req.(*RegisterNodeWithHubRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	default:
		return fmt.Errorf("unknown method: %s", method)
	}
}

// InvokeStream implements synurang.StreamInvoker (zero-copy).
func (i *ffiInvoker) InvokeStream(ctx context.Context, method string, stream synurang.ServerStream) error {
	switch method {
	case "/nitella.local.MobileLogicService/StreamApprovals":
		// Server streaming (zero-copy)
		reqMsg, err := stream.RecvMsgDirect()
		if err != nil {
			return err
		}
		req := reqMsg.(*StreamApprovalsRequest)
		return i.server.StreamApprovals(req, &ffiMobileLogicServiceStreamApprovalsStream{stream})
	case "/nitella.local.MobileLogicService/StreamConnections":
		// Server streaming (zero-copy)
		reqMsg, err := stream.RecvMsgDirect()
		if err != nil {
			return err
		}
		req := reqMsg.(*StreamConnectionsRequest)
		return i.server.StreamConnections(req, &ffiMobileLogicServiceStreamConnectionsStream{stream})
	case "/nitella.local.MobileLogicService/StreamP2PStatus":
		// Server streaming (zero-copy)
		reqMsg, err := stream.RecvMsgDirect()
		if err != nil {
			return err
		}
		req := reqMsg.(*empty.Empty)
		return i.server.StreamP2PStatus(req, &ffiMobileLogicServiceStreamP2PStatusStream{stream})
	case "/nitella.local.MobileLogicService/StreamMetrics":
		// Server streaming (zero-copy)
		reqMsg, err := stream.RecvMsgDirect()
		if err != nil {
			return err
		}
		req := reqMsg.(*StreamMetricsRequest)
		return i.server.StreamMetrics(req, &ffiMobileLogicServiceStreamMetricsStream{stream})
	default:
		return fmt.Errorf("unknown streaming method: %s", method)
	}
}

// =============================================================================
// Stream Wrappers (zero-copy)
// =============================================================================

// ffiMobileLogicServiceStreamApprovalsStream wraps ServerStream for zero-copy MobileLogicService.StreamApprovals
type ffiMobileLogicServiceStreamApprovalsStream struct {
	synurang.ServerStream
}

func (s *ffiMobileLogicServiceStreamApprovalsStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiMobileLogicServiceStreamApprovalsStream) Send(m *ApprovalRequest) error {
	return s.ServerStream.SendMsg(m)
}

var _ MobileLogicService_StreamApprovalsServer = (*ffiMobileLogicServiceStreamApprovalsStream)(nil)

// ffiMobileLogicServiceStreamConnectionsStream wraps ServerStream for zero-copy MobileLogicService.StreamConnections
type ffiMobileLogicServiceStreamConnectionsStream struct {
	synurang.ServerStream
}

func (s *ffiMobileLogicServiceStreamConnectionsStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiMobileLogicServiceStreamConnectionsStream) Send(m *ConnectionEvent) error {
	return s.ServerStream.SendMsg(m)
}

var _ MobileLogicService_StreamConnectionsServer = (*ffiMobileLogicServiceStreamConnectionsStream)(nil)

// ffiMobileLogicServiceStreamP2PStatusStream wraps ServerStream for zero-copy MobileLogicService.StreamP2PStatus
type ffiMobileLogicServiceStreamP2PStatusStream struct {
	synurang.ServerStream
}

func (s *ffiMobileLogicServiceStreamP2PStatusStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiMobileLogicServiceStreamP2PStatusStream) Send(m *P2PStatus) error {
	return s.ServerStream.SendMsg(m)
}

var _ MobileLogicService_StreamP2PStatusServer = (*ffiMobileLogicServiceStreamP2PStatusStream)(nil)

// ffiMobileLogicServiceStreamMetricsStream wraps ServerStream for zero-copy MobileLogicService.StreamMetrics
type ffiMobileLogicServiceStreamMetricsStream struct {
	synurang.ServerStream
}

func (s *ffiMobileLogicServiceStreamMetricsStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiMobileLogicServiceStreamMetricsStream) Send(m *NodeMetrics) error {
	return s.ServerStream.SendMsg(m)
}

var _ MobileLogicService_StreamMetricsServer = (*ffiMobileLogicServiceStreamMetricsStream)(nil)

var _ synurang.Invoker = (*ffiInvoker)(nil)

// =============================================================================
// FFI Client - convenience wrapper for synurang.FfiClientConn
// =============================================================================

func NewFfiClientConn(server FfiServer) grpc.ClientConnInterface {
	return synurang.NewFfiClientConn(&ffiInvoker{server: server})
}
