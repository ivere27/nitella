// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.12.4
// source: local/nitella_local.proto

package local

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	proxy "github.com/ivere27/nitella/pkg/api/proxy"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MobileLogicService_Initialize_FullMethodName                  = "/nitella.local.MobileLogicService/Initialize"
	MobileLogicService_Shutdown_FullMethodName                    = "/nitella.local.MobileLogicService/Shutdown"
	MobileLogicService_GetBootstrapState_FullMethodName           = "/nitella.local.MobileLogicService/GetBootstrapState"
	MobileLogicService_GetIdentity_FullMethodName                 = "/nitella.local.MobileLogicService/GetIdentity"
	MobileLogicService_CreateIdentity_FullMethodName              = "/nitella.local.MobileLogicService/CreateIdentity"
	MobileLogicService_RestoreIdentity_FullMethodName             = "/nitella.local.MobileLogicService/RestoreIdentity"
	MobileLogicService_ImportIdentity_FullMethodName              = "/nitella.local.MobileLogicService/ImportIdentity"
	MobileLogicService_UnlockIdentity_FullMethodName              = "/nitella.local.MobileLogicService/UnlockIdentity"
	MobileLogicService_LockIdentity_FullMethodName                = "/nitella.local.MobileLogicService/LockIdentity"
	MobileLogicService_ChangePassphrase_FullMethodName            = "/nitella.local.MobileLogicService/ChangePassphrase"
	MobileLogicService_EvaluatePassphrase_FullMethodName          = "/nitella.local.MobileLogicService/EvaluatePassphrase"
	MobileLogicService_ResetIdentity_FullMethodName               = "/nitella.local.MobileLogicService/ResetIdentity"
	MobileLogicService_ListNodes_FullMethodName                   = "/nitella.local.MobileLogicService/ListNodes"
	MobileLogicService_GetNode_FullMethodName                     = "/nitella.local.MobileLogicService/GetNode"
	MobileLogicService_GetNodeDetailSnapshot_FullMethodName       = "/nitella.local.MobileLogicService/GetNodeDetailSnapshot"
	MobileLogicService_UpdateNode_FullMethodName                  = "/nitella.local.MobileLogicService/UpdateNode"
	MobileLogicService_RemoveNode_FullMethodName                  = "/nitella.local.MobileLogicService/RemoveNode"
	MobileLogicService_AddNodeDirect_FullMethodName               = "/nitella.local.MobileLogicService/AddNodeDirect"
	MobileLogicService_TestDirectConnection_FullMethodName        = "/nitella.local.MobileLogicService/TestDirectConnection"
	MobileLogicService_ListProxies_FullMethodName                 = "/nitella.local.MobileLogicService/ListProxies"
	MobileLogicService_GetProxiesSnapshot_FullMethodName          = "/nitella.local.MobileLogicService/GetProxiesSnapshot"
	MobileLogicService_GetProxy_FullMethodName                    = "/nitella.local.MobileLogicService/GetProxy"
	MobileLogicService_AddProxy_FullMethodName                    = "/nitella.local.MobileLogicService/AddProxy"
	MobileLogicService_UpdateProxy_FullMethodName                 = "/nitella.local.MobileLogicService/UpdateProxy"
	MobileLogicService_SetNodeProxiesRunning_FullMethodName       = "/nitella.local.MobileLogicService/SetNodeProxiesRunning"
	MobileLogicService_RemoveProxy_FullMethodName                 = "/nitella.local.MobileLogicService/RemoveProxy"
	MobileLogicService_ListRules_FullMethodName                   = "/nitella.local.MobileLogicService/ListRules"
	MobileLogicService_GetRule_FullMethodName                     = "/nitella.local.MobileLogicService/GetRule"
	MobileLogicService_AddRule_FullMethodName                     = "/nitella.local.MobileLogicService/AddRule"
	MobileLogicService_AddQuickRule_FullMethodName                = "/nitella.local.MobileLogicService/AddQuickRule"
	MobileLogicService_UpdateRule_FullMethodName                  = "/nitella.local.MobileLogicService/UpdateRule"
	MobileLogicService_RemoveRule_FullMethodName                  = "/nitella.local.MobileLogicService/RemoveRule"
	MobileLogicService_BlockIP_FullMethodName                     = "/nitella.local.MobileLogicService/BlockIP"
	MobileLogicService_BlockISP_FullMethodName                    = "/nitella.local.MobileLogicService/BlockISP"
	MobileLogicService_BlockCountry_FullMethodName                = "/nitella.local.MobileLogicService/BlockCountry"
	MobileLogicService_AddGlobalRule_FullMethodName               = "/nitella.local.MobileLogicService/AddGlobalRule"
	MobileLogicService_ListGlobalRules_FullMethodName             = "/nitella.local.MobileLogicService/ListGlobalRules"
	MobileLogicService_RemoveGlobalRule_FullMethodName            = "/nitella.local.MobileLogicService/RemoveGlobalRule"
	MobileLogicService_ListPendingApprovals_FullMethodName        = "/nitella.local.MobileLogicService/ListPendingApprovals"
	MobileLogicService_GetApprovalsSnapshot_FullMethodName        = "/nitella.local.MobileLogicService/GetApprovalsSnapshot"
	MobileLogicService_ApproveRequest_FullMethodName              = "/nitella.local.MobileLogicService/ApproveRequest"
	MobileLogicService_DenyRequest_FullMethodName                 = "/nitella.local.MobileLogicService/DenyRequest"
	MobileLogicService_ResolveApprovalDecision_FullMethodName     = "/nitella.local.MobileLogicService/ResolveApprovalDecision"
	MobileLogicService_StreamApprovals_FullMethodName             = "/nitella.local.MobileLogicService/StreamApprovals"
	MobileLogicService_ListApprovalHistory_FullMethodName         = "/nitella.local.MobileLogicService/ListApprovalHistory"
	MobileLogicService_ClearApprovalHistory_FullMethodName        = "/nitella.local.MobileLogicService/ClearApprovalHistory"
	MobileLogicService_GetConnectionStats_FullMethodName          = "/nitella.local.MobileLogicService/GetConnectionStats"
	MobileLogicService_ListConnections_FullMethodName             = "/nitella.local.MobileLogicService/ListConnections"
	MobileLogicService_GetIPStats_FullMethodName                  = "/nitella.local.MobileLogicService/GetIPStats"
	MobileLogicService_GetGeoStats_FullMethodName                 = "/nitella.local.MobileLogicService/GetGeoStats"
	MobileLogicService_StreamConnections_FullMethodName           = "/nitella.local.MobileLogicService/StreamConnections"
	MobileLogicService_CloseConnection_FullMethodName             = "/nitella.local.MobileLogicService/CloseConnection"
	MobileLogicService_CloseAllConnections_FullMethodName         = "/nitella.local.MobileLogicService/CloseAllConnections"
	MobileLogicService_CloseAllNodeConnections_FullMethodName     = "/nitella.local.MobileLogicService/CloseAllNodeConnections"
	MobileLogicService_StartPairing_FullMethodName                = "/nitella.local.MobileLogicService/StartPairing"
	MobileLogicService_JoinPairing_FullMethodName                 = "/nitella.local.MobileLogicService/JoinPairing"
	MobileLogicService_CompletePairing_FullMethodName             = "/nitella.local.MobileLogicService/CompletePairing"
	MobileLogicService_FinalizePairing_FullMethodName             = "/nitella.local.MobileLogicService/FinalizePairing"
	MobileLogicService_CancelPairing_FullMethodName               = "/nitella.local.MobileLogicService/CancelPairing"
	MobileLogicService_GenerateQRCode_FullMethodName              = "/nitella.local.MobileLogicService/GenerateQRCode"
	MobileLogicService_ScanQRCode_FullMethodName                  = "/nitella.local.MobileLogicService/ScanQRCode"
	MobileLogicService_GenerateQRResponse_FullMethodName          = "/nitella.local.MobileLogicService/GenerateQRResponse"
	MobileLogicService_ListTemplates_FullMethodName               = "/nitella.local.MobileLogicService/ListTemplates"
	MobileLogicService_GetTemplate_FullMethodName                 = "/nitella.local.MobileLogicService/GetTemplate"
	MobileLogicService_CreateTemplate_FullMethodName              = "/nitella.local.MobileLogicService/CreateTemplate"
	MobileLogicService_ApplyTemplate_FullMethodName               = "/nitella.local.MobileLogicService/ApplyTemplate"
	MobileLogicService_DeleteTemplate_FullMethodName              = "/nitella.local.MobileLogicService/DeleteTemplate"
	MobileLogicService_SyncTemplates_FullMethodName               = "/nitella.local.MobileLogicService/SyncTemplates"
	MobileLogicService_ExportTemplateYaml_FullMethodName          = "/nitella.local.MobileLogicService/ExportTemplateYaml"
	MobileLogicService_ImportTemplateYaml_FullMethodName          = "/nitella.local.MobileLogicService/ImportTemplateYaml"
	MobileLogicService_GetSettings_FullMethodName                 = "/nitella.local.MobileLogicService/GetSettings"
	MobileLogicService_GetSettingsOverviewSnapshot_FullMethodName = "/nitella.local.MobileLogicService/GetSettingsOverviewSnapshot"
	MobileLogicService_UpdateSettings_FullMethodName              = "/nitella.local.MobileLogicService/UpdateSettings"
	MobileLogicService_RegisterFCMToken_FullMethodName            = "/nitella.local.MobileLogicService/RegisterFCMToken"
	MobileLogicService_UnregisterFCMToken_FullMethodName          = "/nitella.local.MobileLogicService/UnregisterFCMToken"
	MobileLogicService_ConnectToHub_FullMethodName                = "/nitella.local.MobileLogicService/ConnectToHub"
	MobileLogicService_DisconnectFromHub_FullMethodName           = "/nitella.local.MobileLogicService/DisconnectFromHub"
	MobileLogicService_GetHubStatus_FullMethodName                = "/nitella.local.MobileLogicService/GetHubStatus"
	MobileLogicService_GetHubSettingsSnapshot_FullMethodName      = "/nitella.local.MobileLogicService/GetHubSettingsSnapshot"
	MobileLogicService_GetHubOverview_FullMethodName              = "/nitella.local.MobileLogicService/GetHubOverview"
	MobileLogicService_GetHubDashboardSnapshot_FullMethodName     = "/nitella.local.MobileLogicService/GetHubDashboardSnapshot"
	MobileLogicService_RegisterUser_FullMethodName                = "/nitella.local.MobileLogicService/RegisterUser"
	MobileLogicService_FetchHubCA_FullMethodName                  = "/nitella.local.MobileLogicService/FetchHubCA"
	MobileLogicService_OnboardHub_FullMethodName                  = "/nitella.local.MobileLogicService/OnboardHub"
	MobileLogicService_EnsureHubConnected_FullMethodName          = "/nitella.local.MobileLogicService/EnsureHubConnected"
	MobileLogicService_EnsureHubRegistered_FullMethodName         = "/nitella.local.MobileLogicService/EnsureHubRegistered"
	MobileLogicService_ResolveHubTrustChallenge_FullMethodName    = "/nitella.local.MobileLogicService/ResolveHubTrustChallenge"
	MobileLogicService_GetP2PStatus_FullMethodName                = "/nitella.local.MobileLogicService/GetP2PStatus"
	MobileLogicService_GetP2PSettingsSnapshot_FullMethodName      = "/nitella.local.MobileLogicService/GetP2PSettingsSnapshot"
	MobileLogicService_StreamP2PStatus_FullMethodName             = "/nitella.local.MobileLogicService/StreamP2PStatus"
	MobileLogicService_SetP2PMode_FullMethodName                  = "/nitella.local.MobileLogicService/SetP2PMode"
	MobileLogicService_LookupIP_FullMethodName                    = "/nitella.local.MobileLogicService/LookupIP"
	MobileLogicService_ConfigureGeoIP_FullMethodName              = "/nitella.local.MobileLogicService/ConfigureGeoIP"
	MobileLogicService_GetGeoIPStatus_FullMethodName              = "/nitella.local.MobileLogicService/GetGeoIPStatus"
	MobileLogicService_RestartListeners_FullMethodName            = "/nitella.local.MobileLogicService/RestartListeners"
	MobileLogicService_ListLocalProxyConfigs_FullMethodName       = "/nitella.local.MobileLogicService/ListLocalProxyConfigs"
	MobileLogicService_GetLocalProxyConfig_FullMethodName         = "/nitella.local.MobileLogicService/GetLocalProxyConfig"
	MobileLogicService_ImportLocalProxyConfig_FullMethodName      = "/nitella.local.MobileLogicService/ImportLocalProxyConfig"
	MobileLogicService_SaveLocalProxyConfig_FullMethodName        = "/nitella.local.MobileLogicService/SaveLocalProxyConfig"
	MobileLogicService_DeleteLocalProxyConfig_FullMethodName      = "/nitella.local.MobileLogicService/DeleteLocalProxyConfig"
	MobileLogicService_ValidateLocalProxyConfig_FullMethodName    = "/nitella.local.MobileLogicService/ValidateLocalProxyConfig"
	MobileLogicService_PushProxyRevision_FullMethodName           = "/nitella.local.MobileLogicService/PushProxyRevision"
	MobileLogicService_PushLocalProxyRevision_FullMethodName      = "/nitella.local.MobileLogicService/PushLocalProxyRevision"
	MobileLogicService_PullProxyRevision_FullMethodName           = "/nitella.local.MobileLogicService/PullProxyRevision"
	MobileLogicService_DiffProxyRevisions_FullMethodName          = "/nitella.local.MobileLogicService/DiffProxyRevisions"
	MobileLogicService_ListProxyRevisions_FullMethodName          = "/nitella.local.MobileLogicService/ListProxyRevisions"
	MobileLogicService_FlushProxyRevisions_FullMethodName         = "/nitella.local.MobileLogicService/FlushProxyRevisions"
	MobileLogicService_ListProxyConfigs_FullMethodName            = "/nitella.local.MobileLogicService/ListProxyConfigs"
	MobileLogicService_CreateProxyConfig_FullMethodName           = "/nitella.local.MobileLogicService/CreateProxyConfig"
	MobileLogicService_DeleteProxyConfig_FullMethodName           = "/nitella.local.MobileLogicService/DeleteProxyConfig"
	MobileLogicService_ApplyProxyToNode_FullMethodName            = "/nitella.local.MobileLogicService/ApplyProxyToNode"
	MobileLogicService_UnapplyProxyFromNode_FullMethodName        = "/nitella.local.MobileLogicService/UnapplyProxyFromNode"
	MobileLogicService_GetAppliedProxies_FullMethodName           = "/nitella.local.MobileLogicService/GetAppliedProxies"
	MobileLogicService_AllowIP_FullMethodName                     = "/nitella.local.MobileLogicService/AllowIP"
	MobileLogicService_StreamMetrics_FullMethodName               = "/nitella.local.MobileLogicService/StreamMetrics"
	MobileLogicService_GetDebugRuntimeStats_FullMethodName        = "/nitella.local.MobileLogicService/GetDebugRuntimeStats"
	MobileLogicService_GetLogsStats_FullMethodName                = "/nitella.local.MobileLogicService/GetLogsStats"
	MobileLogicService_ListLogs_FullMethodName                    = "/nitella.local.MobileLogicService/ListLogs"
	MobileLogicService_DeleteLogs_FullMethodName                  = "/nitella.local.MobileLogicService/DeleteLogs"
	MobileLogicService_CleanupOldLogs_FullMethodName              = "/nitella.local.MobileLogicService/CleanupOldLogs"
	MobileLogicService_GetNodeFromHub_FullMethodName              = "/nitella.local.MobileLogicService/GetNodeFromHub"
	MobileLogicService_RegisterNodeWithHub_FullMethodName         = "/nitella.local.MobileLogicService/RegisterNodeWithHub"
)

// MobileLogicServiceClient is the client API for MobileLogicService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MobileLogicServiceClient interface {
	// Initialize the mobile backend with data directory
	Initialize(ctx context.Context, in *InitializeRequest, opts ...grpc.CallOption) (*InitializeResponse, error)
	// Shutdown the mobile backend gracefully
	Shutdown(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// Get backend-owned startup state for app routing (setup/auth/ready)
	GetBootstrapState(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*BootstrapStateResponse, error)
	// Get current identity status
	GetIdentity(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*IdentityInfo, error)
	// Create new identity with generated mnemonic
	CreateIdentity(ctx context.Context, in *CreateIdentityRequest, opts ...grpc.CallOption) (*CreateIdentityResponse, error)
	// Restore identity from existing mnemonic
	RestoreIdentity(ctx context.Context, in *RestoreIdentityRequest, opts ...grpc.CallOption) (*RestoreIdentityResponse, error)
	// Import identity from certificate/key PEM files
	ImportIdentity(ctx context.Context, in *ImportIdentityRequest, opts ...grpc.CallOption) (*ImportIdentityResponse, error)
	// Unlock identity with passphrase (if encrypted)
	UnlockIdentity(ctx context.Context, in *UnlockIdentityRequest, opts ...grpc.CallOption) (*UnlockIdentityResponse, error)
	// Lock identity (clear from memory)
	LockIdentity(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// Change passphrase
	ChangePassphrase(ctx context.Context, in *ChangePassphraseRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Evaluate passphrase strength/policy (backend-owned security logic)
	EvaluatePassphrase(ctx context.Context, in *EvaluatePassphraseRequest, opts ...grpc.CallOption) (*EvaluatePassphraseResponse, error)
	// Delete identity and all associated data (nodes, settings, templates)
	ResetIdentity(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// List all paired nodes
	ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (*ListNodesResponse, error)
	// Get detailed info for a specific node
	GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*NodeInfo, error)
	// Get node detail snapshot for status/rules/stats surfaces
	GetNodeDetailSnapshot(ctx context.Context, in *GetNodeDetailSnapshotRequest, opts ...grpc.CallOption) (*NodeDetailSnapshot, error)
	// Update node metadata (name, tags)
	UpdateNode(ctx context.Context, in *UpdateNodeRequest, opts ...grpc.CallOption) (*NodeInfo, error)
	// Remove/unpair a node
	RemoveNode(ctx context.Context, in *RemoveNodeRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Add a node with direct connection (no Hub required)
	// Used to connect to standalone nitellad admin API
	AddNodeDirect(ctx context.Context, in *AddNodeDirectRequest, opts ...grpc.CallOption) (*AddNodeDirectResponse, error)
	// Test connection to a direct node
	TestDirectConnection(ctx context.Context, in *TestDirectConnectionRequest, opts ...grpc.CallOption) (*TestDirectConnectionResponse, error)
	// List proxies on a node
	ListProxies(ctx context.Context, in *ListProxiesRequest, opts ...grpc.CallOption) (*ListProxiesResponse, error)
	// Get node+proxy snapshot for proxy surfaces
	GetProxiesSnapshot(ctx context.Context, in *GetProxiesSnapshotRequest, opts ...grpc.CallOption) (*GetProxiesSnapshotResponse, error)
	// Get proxy details
	GetProxy(ctx context.Context, in *GetProxyRequest, opts ...grpc.CallOption) (*ProxyInfo, error)
	// Create new proxy on node
	AddProxy(ctx context.Context, in *AddProxyRequest, opts ...grpc.CallOption) (*ProxyInfo, error)
	// Update proxy configuration
	UpdateProxy(ctx context.Context, in *UpdateProxyRequest, opts ...grpc.CallOption) (*ProxyInfo, error)
	// Enable/disable all proxies on a node in one backend-owned operation
	SetNodeProxiesRunning(ctx context.Context, in *SetNodeProxiesRunningRequest, opts ...grpc.CallOption) (*SetNodeProxiesRunningResponse, error)
	// Remove proxy from node
	RemoveProxy(ctx context.Context, in *RemoveProxyRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// List rules for a proxy
	ListRules(ctx context.Context, in *ListRulesRequest, opts ...grpc.CallOption) (*ListRulesResponse, error)
	// Get rule details
	GetRule(ctx context.Context, in *GetRuleRequest, opts ...grpc.CallOption) (*proxy.Rule, error)
	// Add new rule to proxy
	AddRule(ctx context.Context, in *AddRuleRequest, opts ...grpc.CallOption) (*proxy.Rule, error)
	// Add a quick rule with backend-owned mapping (block/allow/ip/geo shortcuts)
	AddQuickRule(ctx context.Context, in *AddQuickRuleRequest, opts ...grpc.CallOption) (*AddQuickRuleResponse, error)
	// Update existing rule
	UpdateRule(ctx context.Context, in *UpdateRuleRequest, opts ...grpc.CallOption) (*proxy.Rule, error)
	// Remove rule from proxy
	RemoveRule(ctx context.Context, in *RemoveRuleRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Block IP address (creates block rule)
	BlockIP(ctx context.Context, in *BlockIPRequest, opts ...grpc.CallOption) (*BlockIPResponse, error)
	// Block ISP (creates block rule)
	BlockISP(ctx context.Context, in *BlockISPRequest, opts ...grpc.CallOption) (*BlockISPResponse, error)
	// Block Country (creates block rule)
	BlockCountry(ctx context.Context, in *BlockCountryRequest, opts ...grpc.CallOption) (*BlockCountryResponse, error)
	// Global Rules (node-level, cross-proxy runtime rules)
	AddGlobalRule(ctx context.Context, in *AddGlobalRuleRequest, opts ...grpc.CallOption) (*AddGlobalRuleResponse, error)
	ListGlobalRules(ctx context.Context, in *ListGlobalRulesRequest, opts ...grpc.CallOption) (*ListGlobalRulesResponse, error)
	RemoveGlobalRule(ctx context.Context, in *RemoveGlobalRuleRequest, opts ...grpc.CallOption) (*RemoveGlobalRuleResponse, error)
	// List pending approval requests (real-time from nodes)
	ListPendingApprovals(ctx context.Context, in *ListPendingApprovalsRequest, opts ...grpc.CallOption) (*ListPendingApprovalsResponse, error)
	// Get pending + history snapshot for approval center views
	GetApprovalsSnapshot(ctx context.Context, in *GetApprovalsSnapshotRequest, opts ...grpc.CallOption) (*GetApprovalsSnapshotResponse, error)
	// Approve a connection request
	ApproveRequest(ctx context.Context, in *ApproveRequestRequest, opts ...grpc.CallOption) (*ApproveRequestResponse, error)
	// Deny a connection request
	DenyRequest(ctx context.Context, in *DenyRequestRequest, opts ...grpc.CallOption) (*DenyRequestResponse, error)
	// Resolve an approval request (backend-owned approve/deny orchestration)
	ResolveApprovalDecision(ctx context.Context, in *ResolveApprovalDecisionRequest, opts ...grpc.CallOption) (*ResolveApprovalDecisionResponse, error)
	// Stream approval requests in real-time
	StreamApprovals(ctx context.Context, in *StreamApprovalsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ApprovalRequest], error)
	// List approval decision history (backend-owned)
	ListApprovalHistory(ctx context.Context, in *ListApprovalHistoryRequest, opts ...grpc.CallOption) (*ListApprovalHistoryResponse, error)
	// Clear approval decision history
	ClearApprovalHistory(ctx context.Context, in *ClearApprovalHistoryRequest, opts ...grpc.CallOption) (*ClearApprovalHistoryResponse, error)
	// Get connection statistics summary
	GetConnectionStats(ctx context.Context, in *GetConnectionStatsRequest, opts ...grpc.CallOption) (*ConnectionStats, error)
	// List active connections on a node/proxy
	ListConnections(ctx context.Context, in *ListConnectionsRequest, opts ...grpc.CallOption) (*ListConnectionsResponse, error)
	// Get IP statistics
	GetIPStats(ctx context.Context, in *GetIPStatsRequest, opts ...grpc.CallOption) (*GetIPStatsResponse, error)
	// Get geo statistics
	GetGeoStats(ctx context.Context, in *GetGeoStatsRequest, opts ...grpc.CallOption) (*GetGeoStatsResponse, error)
	// Stream connection events
	StreamConnections(ctx context.Context, in *StreamConnectionsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ConnectionEvent], error)
	// Close a specific connection
	CloseConnection(ctx context.Context, in *CloseConnectionRequest, opts ...grpc.CallOption) (*CloseConnectionResponse, error)
	// Close all connections on a proxy
	CloseAllConnections(ctx context.Context, in *CloseAllConnectionsRequest, opts ...grpc.CallOption) (*CloseAllConnectionsResponse, error)
	// Close all connections across every proxy on a node
	CloseAllNodeConnections(ctx context.Context, in *CloseAllNodeConnectionsRequest, opts ...grpc.CallOption) (*CloseAllNodeConnectionsResponse, error)
	// Start PAKE pairing session (returns human-readable code)
	StartPairing(ctx context.Context, in *StartPairingRequest, opts ...grpc.CallOption) (*StartPairingResponse, error)
	// Join existing pairing session using code from node
	JoinPairing(ctx context.Context, in *JoinPairingRequest, opts ...grpc.CallOption) (*JoinPairingResponse, error)
	// Complete PAKE pairing (after code exchange)
	CompletePairing(ctx context.Context, in *CompletePairingRequest, opts ...grpc.CallOption) (*CompletePairingResponse, error)
	// Finalize pairing decision (approve/reject) for PAKE or offline QR sessions
	FinalizePairing(ctx context.Context, in *FinalizePairingRequest, opts ...grpc.CallOption) (*FinalizePairingResponse, error)
	// Cancel ongoing pairing session
	CancelPairing(ctx context.Context, in *CancelPairingRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Generate QR code data for offline pairing
	GenerateQRCode(ctx context.Context, in *GenerateQRCodeRequest, opts ...grpc.CallOption) (*GenerateQRCodeResponse, error)
	// Scan and process QR code from node
	ScanQRCode(ctx context.Context, in *ScanQRCodeRequest, opts ...grpc.CallOption) (*ScanQRCodeResponse, error)
	// Generate QR response (signed certificate) for node to scan
	GenerateQRResponse(ctx context.Context, in *GenerateQRReplyRequest, opts ...grpc.CallOption) (*GenerateQRReplyResponse, error)
	// List available templates
	ListTemplates(ctx context.Context, in *ListTemplatesRequest, opts ...grpc.CallOption) (*ListTemplatesResponse, error)
	// Get template details
	GetTemplate(ctx context.Context, in *GetTemplateRequest, opts ...grpc.CallOption) (*Template, error)
	// Create new template from current config
	CreateTemplate(ctx context.Context, in *CreateTemplateRequest, opts ...grpc.CallOption) (*Template, error)
	// Apply template to a node
	ApplyTemplate(ctx context.Context, in *ApplyTemplateRequest, opts ...grpc.CallOption) (*ApplyTemplateResponse, error)
	// Delete a template
	DeleteTemplate(ctx context.Context, in *DeleteTemplateRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Sync templates with Hub
	SyncTemplates(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*SyncTemplatesResponse, error)
	// Export template as YAML (backend-owned format/policy)
	ExportTemplateYaml(ctx context.Context, in *ExportTemplateYamlRequest, opts ...grpc.CallOption) (*ExportTemplateYamlResponse, error)
	// Import template from YAML (backend-owned parsing/validation)
	ImportTemplateYaml(ctx context.Context, in *ImportTemplateYamlRequest, opts ...grpc.CallOption) (*ImportTemplateYamlResponse, error)
	// Get current settings
	GetSettings(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Settings, error)
	// Get identity + hub + p2p settings snapshot for thin settings surfaces
	GetSettingsOverviewSnapshot(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*SettingsOverviewSnapshot, error)
	// Update settings
	UpdateSettings(ctx context.Context, in *UpdateSettingsRequest, opts ...grpc.CallOption) (*Settings, error)
	// Register FCM token for push notifications
	RegisterFCMToken(ctx context.Context, in *RegisterFCMTokenRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Unregister FCM token
	UnregisterFCMToken(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// Connect to Hub server
	ConnectToHub(ctx context.Context, in *ConnectToHubRequest, opts ...grpc.CallOption) (*ConnectToHubResponse, error)
	// Disconnect from Hub
	DisconnectFromHub(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// Get Hub connection status
	GetHubStatus(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*HubStatus, error)
	// Get hub settings snapshot for settings/onboarding surfaces
	GetHubSettingsSnapshot(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*HubSettingsSnapshot, error)
	// Get aggregated hub/node overview for thin clients
	GetHubOverview(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*HubOverview, error)
	// Get hub dashboard snapshot for home/status surfaces
	GetHubDashboardSnapshot(ctx context.Context, in *GetHubDashboardSnapshotRequest, opts ...grpc.CallOption) (*HubDashboardSnapshot, error)
	// Register user with Hub
	RegisterUser(ctx context.Context, in *RegisterUserRequest, opts ...grpc.CallOption) (*RegisterUserResponse, error)
	// Fetch Hub's CA certificate for TOFU (Trust On First Use) verification
	FetchHubCA(ctx context.Context, in *FetchHubCARequest, opts ...grpc.CallOption) (*FetchHubCAResponse, error)
	// Run Hub onboarding flow (connect + optional TOFU + register)
	OnboardHub(ctx context.Context, in *OnboardHubRequest, opts ...grpc.CallOption) (*OnboardHubResponse, error)
	// Ensure Hub connection using backend-owned defaults/state (no registration)
	EnsureHubConnected(ctx context.Context, in *EnsureHubConnectedRequest, opts ...grpc.CallOption) (*OnboardHubResponse, error)
	// Ensure Hub registration using backend-owned defaults/state
	EnsureHubRegistered(ctx context.Context, in *EnsureHubRegisteredRequest, opts ...grpc.CallOption) (*OnboardHubResponse, error)
	// Resolve a pending Hub trust challenge and continue onboarding
	ResolveHubTrustChallenge(ctx context.Context, in *ResolveHubTrustChallengeRequest, opts ...grpc.CallOption) (*OnboardHubResponse, error)
	// Get current P2P connection status
	GetP2PStatus(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*P2PStatus, error)
	// Get P2P + settings snapshot for P2P configuration surfaces
	GetP2PSettingsSnapshot(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*P2PSettingsSnapshot, error)
	// Stream P2P status changes
	StreamP2PStatus(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[P2PStatus], error)
	// Set P2P mode (auto, always, disabled)
	SetP2PMode(ctx context.Context, in *SetP2PModeRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Lookup IP geolocation (with cache indicator)
	LookupIP(ctx context.Context, in *LookupIPRequest, opts ...grpc.CallOption) (*LookupIPResponse, error)
	// Configure GeoIP mode/provider/database for a node
	ConfigureGeoIP(ctx context.Context, in *ConfigureGeoIPNodeRequest, opts ...grpc.CallOption) (*proxy.ConfigureGeoIPResponse, error)
	// Get GeoIP runtime status for a node
	GetGeoIPStatus(ctx context.Context, in *GetGeoIPStatusNodeRequest, opts ...grpc.CallOption) (*proxy.GetGeoIPStatusResponse, error)
	// Restart proxy listeners on a node
	RestartListeners(ctx context.Context, in *RestartListenersNodeRequest, opts ...grpc.CallOption) (*proxy.RestartListenersResponse, error)
	// List proxy configs stored locally on this device
	ListLocalProxyConfigs(ctx context.Context, in *ListLocalProxyConfigsRequest, opts ...grpc.CallOption) (*ListLocalProxyConfigsResponse, error)
	// Get local proxy config content + metadata
	GetLocalProxyConfig(ctx context.Context, in *GetLocalProxyConfigRequest, opts ...grpc.CallOption) (*GetLocalProxyConfigResponse, error)
	// Import raw proxy file content into local storage
	ImportLocalProxyConfig(ctx context.Context, in *ImportLocalProxyConfigRequest, opts ...grpc.CallOption) (*ImportLocalProxyConfigResponse, error)
	// Save/update local proxy config content + metadata
	SaveLocalProxyConfig(ctx context.Context, in *SaveLocalProxyConfigRequest, opts ...grpc.CallOption) (*SaveLocalProxyConfigResponse, error)
	// Delete a local proxy config
	DeleteLocalProxyConfig(ctx context.Context, in *DeleteLocalProxyConfigRequest, opts ...grpc.CallOption) (*DeleteLocalProxyConfigResponse, error)
	// Validate local proxy config (checksum/header/YAML/required sections)
	ValidateLocalProxyConfig(ctx context.Context, in *ValidateLocalProxyConfigRequest, opts ...grpc.CallOption) (*ValidateLocalProxyConfigResponse, error)
	// Push a proxy revision to Hub (encrypt + store)
	PushProxyRevision(ctx context.Context, in *PushProxyRevisionRequest, opts ...grpc.CallOption) (*PushProxyRevisionResponse, error)
	// Push locally-stored proxy revision to Hub (backend orchestration)
	PushLocalProxyRevision(ctx context.Context, in *PushLocalProxyRevisionRequest, opts ...grpc.CallOption) (*PushLocalProxyRevisionResponse, error)
	// Pull a proxy revision from Hub (fetch + decrypt)
	PullProxyRevision(ctx context.Context, in *PullProxyRevisionRequest, opts ...grpc.CallOption) (*PullProxyRevisionResponse, error)
	// Diff local/remote proxy revisions in backend
	DiffProxyRevisions(ctx context.Context, in *DiffProxyRevisionsRequest, opts ...grpc.CallOption) (*DiffProxyRevisionsResponse, error)
	// List proxy revision history on Hub
	ListProxyRevisions(ctx context.Context, in *ListProxyRevisionsRequest, opts ...grpc.CallOption) (*ListProxyRevisionsResponse, error)
	// Flush old proxy revisions on Hub
	FlushProxyRevisions(ctx context.Context, in *FlushProxyRevisionsRequest, opts ...grpc.CallOption) (*FlushProxyRevisionsResponse, error)
	// List proxy configs stored on Hub
	ListProxyConfigs(ctx context.Context, in *ListProxyConfigsRequest, opts ...grpc.CallOption) (*ListProxyConfigsResponse, error)
	// Create a proxy config entry on Hub
	CreateProxyConfig(ctx context.Context, in *CreateProxyConfigRequest, opts ...grpc.CallOption) (*CreateProxyConfigResponse, error)
	// Delete a proxy config from Hub
	DeleteProxyConfig(ctx context.Context, in *DeleteProxyConfigRequest, opts ...grpc.CallOption) (*DeleteProxyConfigResponse, error)
	// Apply a proxy config to a node
	ApplyProxyToNode(ctx context.Context, in *ApplyProxyToNodeRequest, opts ...grpc.CallOption) (*ApplyProxyToNodeResponse, error)
	// Remove a proxy config from a node
	UnapplyProxyFromNode(ctx context.Context, in *UnapplyProxyFromNodeRequest, opts ...grpc.CallOption) (*UnapplyProxyFromNodeResponse, error)
	// Get proxies applied on a node
	GetAppliedProxies(ctx context.Context, in *GetAppliedProxiesRequest, opts ...grpc.CallOption) (*GetAppliedProxiesResponse, error)
	// Allow an IP address (creates allow rule)
	AllowIP(ctx context.Context, in *AllowIPRequest, opts ...grpc.CallOption) (*AllowIPResponse, error)
	// Stream metrics from a node
	StreamMetrics(ctx context.Context, in *StreamMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[NodeMetrics], error)
	// Get local runtime debug stats from MobileLogicService process
	GetDebugRuntimeStats(ctx context.Context, in *GetDebugRuntimeStatsRequest, opts ...grpc.CallOption) (*DebugRuntimeStats, error)
	// Get logs storage statistics
	GetLogsStats(ctx context.Context, in *GetLogsStatsRequest, opts ...grpc.CallOption) (*GetLogsStatsResponse, error)
	// List logs for a routing token
	ListLogs(ctx context.Context, in *ListLogsRequest, opts ...grpc.CallOption) (*ListLogsResponse, error)
	// Delete logs
	DeleteLogs(ctx context.Context, in *DeleteLogsRequest, opts ...grpc.CallOption) (*DeleteLogsResponse, error)
	// Clean up old logs
	CleanupOldLogs(ctx context.Context, in *CleanupOldLogsRequest, opts ...grpc.CallOption) (*CleanupOldLogsResponse, error)
	// Get node info directly from Hub (not via E2E command)
	GetNodeFromHub(ctx context.Context, in *GetNodeFromHubRequest, opts ...grpc.CallOption) (*GetNodeFromHubResponse, error)
	// Register a node with Hub using an existing certificate (after PAKE pairing)
	RegisterNodeWithHub(ctx context.Context, in *RegisterNodeWithHubRequest, opts ...grpc.CallOption) (*RegisterNodeWithHubResponse, error)
}

type mobileLogicServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMobileLogicServiceClient(cc grpc.ClientConnInterface) MobileLogicServiceClient {
	return &mobileLogicServiceClient{cc}
}

func (c *mobileLogicServiceClient) Initialize(ctx context.Context, in *InitializeRequest, opts ...grpc.CallOption) (*InitializeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitializeResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_Initialize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) Shutdown(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileLogicService_Shutdown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetBootstrapState(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*BootstrapStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BootstrapStateResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_GetBootstrapState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetIdentity(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*IdentityInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IdentityInfo)
	err := c.cc.Invoke(ctx, MobileLogicService_GetIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) CreateIdentity(ctx context.Context, in *CreateIdentityRequest, opts ...grpc.CallOption) (*CreateIdentityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateIdentityResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_CreateIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) RestoreIdentity(ctx context.Context, in *RestoreIdentityRequest, opts ...grpc.CallOption) (*RestoreIdentityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RestoreIdentityResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_RestoreIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ImportIdentity(ctx context.Context, in *ImportIdentityRequest, opts ...grpc.CallOption) (*ImportIdentityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportIdentityResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ImportIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) UnlockIdentity(ctx context.Context, in *UnlockIdentityRequest, opts ...grpc.CallOption) (*UnlockIdentityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnlockIdentityResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_UnlockIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) LockIdentity(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileLogicService_LockIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ChangePassphrase(ctx context.Context, in *ChangePassphraseRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileLogicService_ChangePassphrase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) EvaluatePassphrase(ctx context.Context, in *EvaluatePassphraseRequest, opts ...grpc.CallOption) (*EvaluatePassphraseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EvaluatePassphraseResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_EvaluatePassphrase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ResetIdentity(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileLogicService_ResetIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (*ListNodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNodesResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ListNodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*NodeInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeInfo)
	err := c.cc.Invoke(ctx, MobileLogicService_GetNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetNodeDetailSnapshot(ctx context.Context, in *GetNodeDetailSnapshotRequest, opts ...grpc.CallOption) (*NodeDetailSnapshot, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeDetailSnapshot)
	err := c.cc.Invoke(ctx, MobileLogicService_GetNodeDetailSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) UpdateNode(ctx context.Context, in *UpdateNodeRequest, opts ...grpc.CallOption) (*NodeInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeInfo)
	err := c.cc.Invoke(ctx, MobileLogicService_UpdateNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) RemoveNode(ctx context.Context, in *RemoveNodeRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileLogicService_RemoveNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) AddNodeDirect(ctx context.Context, in *AddNodeDirectRequest, opts ...grpc.CallOption) (*AddNodeDirectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddNodeDirectResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_AddNodeDirect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) TestDirectConnection(ctx context.Context, in *TestDirectConnectionRequest, opts ...grpc.CallOption) (*TestDirectConnectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestDirectConnectionResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_TestDirectConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ListProxies(ctx context.Context, in *ListProxiesRequest, opts ...grpc.CallOption) (*ListProxiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProxiesResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ListProxies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetProxiesSnapshot(ctx context.Context, in *GetProxiesSnapshotRequest, opts ...grpc.CallOption) (*GetProxiesSnapshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProxiesSnapshotResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_GetProxiesSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetProxy(ctx context.Context, in *GetProxyRequest, opts ...grpc.CallOption) (*ProxyInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProxyInfo)
	err := c.cc.Invoke(ctx, MobileLogicService_GetProxy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) AddProxy(ctx context.Context, in *AddProxyRequest, opts ...grpc.CallOption) (*ProxyInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProxyInfo)
	err := c.cc.Invoke(ctx, MobileLogicService_AddProxy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) UpdateProxy(ctx context.Context, in *UpdateProxyRequest, opts ...grpc.CallOption) (*ProxyInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProxyInfo)
	err := c.cc.Invoke(ctx, MobileLogicService_UpdateProxy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) SetNodeProxiesRunning(ctx context.Context, in *SetNodeProxiesRunningRequest, opts ...grpc.CallOption) (*SetNodeProxiesRunningResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetNodeProxiesRunningResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_SetNodeProxiesRunning_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) RemoveProxy(ctx context.Context, in *RemoveProxyRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileLogicService_RemoveProxy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ListRules(ctx context.Context, in *ListRulesRequest, opts ...grpc.CallOption) (*ListRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRulesResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ListRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetRule(ctx context.Context, in *GetRuleRequest, opts ...grpc.CallOption) (*proxy.Rule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(proxy.Rule)
	err := c.cc.Invoke(ctx, MobileLogicService_GetRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) AddRule(ctx context.Context, in *AddRuleRequest, opts ...grpc.CallOption) (*proxy.Rule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(proxy.Rule)
	err := c.cc.Invoke(ctx, MobileLogicService_AddRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) AddQuickRule(ctx context.Context, in *AddQuickRuleRequest, opts ...grpc.CallOption) (*AddQuickRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddQuickRuleResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_AddQuickRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) UpdateRule(ctx context.Context, in *UpdateRuleRequest, opts ...grpc.CallOption) (*proxy.Rule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(proxy.Rule)
	err := c.cc.Invoke(ctx, MobileLogicService_UpdateRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) RemoveRule(ctx context.Context, in *RemoveRuleRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileLogicService_RemoveRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) BlockIP(ctx context.Context, in *BlockIPRequest, opts ...grpc.CallOption) (*BlockIPResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockIPResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_BlockIP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) BlockISP(ctx context.Context, in *BlockISPRequest, opts ...grpc.CallOption) (*BlockISPResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockISPResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_BlockISP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) BlockCountry(ctx context.Context, in *BlockCountryRequest, opts ...grpc.CallOption) (*BlockCountryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockCountryResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_BlockCountry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) AddGlobalRule(ctx context.Context, in *AddGlobalRuleRequest, opts ...grpc.CallOption) (*AddGlobalRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddGlobalRuleResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_AddGlobalRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ListGlobalRules(ctx context.Context, in *ListGlobalRulesRequest, opts ...grpc.CallOption) (*ListGlobalRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGlobalRulesResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ListGlobalRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) RemoveGlobalRule(ctx context.Context, in *RemoveGlobalRuleRequest, opts ...grpc.CallOption) (*RemoveGlobalRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveGlobalRuleResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_RemoveGlobalRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ListPendingApprovals(ctx context.Context, in *ListPendingApprovalsRequest, opts ...grpc.CallOption) (*ListPendingApprovalsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPendingApprovalsResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ListPendingApprovals_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetApprovalsSnapshot(ctx context.Context, in *GetApprovalsSnapshotRequest, opts ...grpc.CallOption) (*GetApprovalsSnapshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetApprovalsSnapshotResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_GetApprovalsSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ApproveRequest(ctx context.Context, in *ApproveRequestRequest, opts ...grpc.CallOption) (*ApproveRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApproveRequestResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ApproveRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) DenyRequest(ctx context.Context, in *DenyRequestRequest, opts ...grpc.CallOption) (*DenyRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DenyRequestResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_DenyRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ResolveApprovalDecision(ctx context.Context, in *ResolveApprovalDecisionRequest, opts ...grpc.CallOption) (*ResolveApprovalDecisionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResolveApprovalDecisionResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ResolveApprovalDecision_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) StreamApprovals(ctx context.Context, in *StreamApprovalsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ApprovalRequest], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MobileLogicService_ServiceDesc.Streams[0], MobileLogicService_StreamApprovals_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamApprovalsRequest, ApprovalRequest]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MobileLogicService_StreamApprovalsClient = grpc.ServerStreamingClient[ApprovalRequest]

func (c *mobileLogicServiceClient) ListApprovalHistory(ctx context.Context, in *ListApprovalHistoryRequest, opts ...grpc.CallOption) (*ListApprovalHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListApprovalHistoryResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ListApprovalHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ClearApprovalHistory(ctx context.Context, in *ClearApprovalHistoryRequest, opts ...grpc.CallOption) (*ClearApprovalHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearApprovalHistoryResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ClearApprovalHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetConnectionStats(ctx context.Context, in *GetConnectionStatsRequest, opts ...grpc.CallOption) (*ConnectionStats, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectionStats)
	err := c.cc.Invoke(ctx, MobileLogicService_GetConnectionStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ListConnections(ctx context.Context, in *ListConnectionsRequest, opts ...grpc.CallOption) (*ListConnectionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListConnectionsResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ListConnections_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetIPStats(ctx context.Context, in *GetIPStatsRequest, opts ...grpc.CallOption) (*GetIPStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetIPStatsResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_GetIPStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetGeoStats(ctx context.Context, in *GetGeoStatsRequest, opts ...grpc.CallOption) (*GetGeoStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGeoStatsResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_GetGeoStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) StreamConnections(ctx context.Context, in *StreamConnectionsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ConnectionEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MobileLogicService_ServiceDesc.Streams[1], MobileLogicService_StreamConnections_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamConnectionsRequest, ConnectionEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MobileLogicService_StreamConnectionsClient = grpc.ServerStreamingClient[ConnectionEvent]

func (c *mobileLogicServiceClient) CloseConnection(ctx context.Context, in *CloseConnectionRequest, opts ...grpc.CallOption) (*CloseConnectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseConnectionResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_CloseConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) CloseAllConnections(ctx context.Context, in *CloseAllConnectionsRequest, opts ...grpc.CallOption) (*CloseAllConnectionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseAllConnectionsResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_CloseAllConnections_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) CloseAllNodeConnections(ctx context.Context, in *CloseAllNodeConnectionsRequest, opts ...grpc.CallOption) (*CloseAllNodeConnectionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseAllNodeConnectionsResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_CloseAllNodeConnections_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) StartPairing(ctx context.Context, in *StartPairingRequest, opts ...grpc.CallOption) (*StartPairingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartPairingResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_StartPairing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) JoinPairing(ctx context.Context, in *JoinPairingRequest, opts ...grpc.CallOption) (*JoinPairingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinPairingResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_JoinPairing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) CompletePairing(ctx context.Context, in *CompletePairingRequest, opts ...grpc.CallOption) (*CompletePairingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompletePairingResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_CompletePairing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) FinalizePairing(ctx context.Context, in *FinalizePairingRequest, opts ...grpc.CallOption) (*FinalizePairingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FinalizePairingResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_FinalizePairing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) CancelPairing(ctx context.Context, in *CancelPairingRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileLogicService_CancelPairing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GenerateQRCode(ctx context.Context, in *GenerateQRCodeRequest, opts ...grpc.CallOption) (*GenerateQRCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateQRCodeResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_GenerateQRCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ScanQRCode(ctx context.Context, in *ScanQRCodeRequest, opts ...grpc.CallOption) (*ScanQRCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScanQRCodeResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ScanQRCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GenerateQRResponse(ctx context.Context, in *GenerateQRReplyRequest, opts ...grpc.CallOption) (*GenerateQRReplyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateQRReplyResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_GenerateQRResponse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ListTemplates(ctx context.Context, in *ListTemplatesRequest, opts ...grpc.CallOption) (*ListTemplatesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTemplatesResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ListTemplates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetTemplate(ctx context.Context, in *GetTemplateRequest, opts ...grpc.CallOption) (*Template, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Template)
	err := c.cc.Invoke(ctx, MobileLogicService_GetTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) CreateTemplate(ctx context.Context, in *CreateTemplateRequest, opts ...grpc.CallOption) (*Template, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Template)
	err := c.cc.Invoke(ctx, MobileLogicService_CreateTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ApplyTemplate(ctx context.Context, in *ApplyTemplateRequest, opts ...grpc.CallOption) (*ApplyTemplateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApplyTemplateResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ApplyTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) DeleteTemplate(ctx context.Context, in *DeleteTemplateRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileLogicService_DeleteTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) SyncTemplates(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*SyncTemplatesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncTemplatesResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_SyncTemplates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ExportTemplateYaml(ctx context.Context, in *ExportTemplateYamlRequest, opts ...grpc.CallOption) (*ExportTemplateYamlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportTemplateYamlResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ExportTemplateYaml_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ImportTemplateYaml(ctx context.Context, in *ImportTemplateYamlRequest, opts ...grpc.CallOption) (*ImportTemplateYamlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportTemplateYamlResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ImportTemplateYaml_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetSettings(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Settings, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Settings)
	err := c.cc.Invoke(ctx, MobileLogicService_GetSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetSettingsOverviewSnapshot(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*SettingsOverviewSnapshot, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SettingsOverviewSnapshot)
	err := c.cc.Invoke(ctx, MobileLogicService_GetSettingsOverviewSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) UpdateSettings(ctx context.Context, in *UpdateSettingsRequest, opts ...grpc.CallOption) (*Settings, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Settings)
	err := c.cc.Invoke(ctx, MobileLogicService_UpdateSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) RegisterFCMToken(ctx context.Context, in *RegisterFCMTokenRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileLogicService_RegisterFCMToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) UnregisterFCMToken(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileLogicService_UnregisterFCMToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ConnectToHub(ctx context.Context, in *ConnectToHubRequest, opts ...grpc.CallOption) (*ConnectToHubResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectToHubResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ConnectToHub_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) DisconnectFromHub(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileLogicService_DisconnectFromHub_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetHubStatus(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*HubStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HubStatus)
	err := c.cc.Invoke(ctx, MobileLogicService_GetHubStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetHubSettingsSnapshot(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*HubSettingsSnapshot, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HubSettingsSnapshot)
	err := c.cc.Invoke(ctx, MobileLogicService_GetHubSettingsSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetHubOverview(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*HubOverview, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HubOverview)
	err := c.cc.Invoke(ctx, MobileLogicService_GetHubOverview_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetHubDashboardSnapshot(ctx context.Context, in *GetHubDashboardSnapshotRequest, opts ...grpc.CallOption) (*HubDashboardSnapshot, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HubDashboardSnapshot)
	err := c.cc.Invoke(ctx, MobileLogicService_GetHubDashboardSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) RegisterUser(ctx context.Context, in *RegisterUserRequest, opts ...grpc.CallOption) (*RegisterUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterUserResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_RegisterUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) FetchHubCA(ctx context.Context, in *FetchHubCARequest, opts ...grpc.CallOption) (*FetchHubCAResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FetchHubCAResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_FetchHubCA_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) OnboardHub(ctx context.Context, in *OnboardHubRequest, opts ...grpc.CallOption) (*OnboardHubResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnboardHubResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_OnboardHub_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) EnsureHubConnected(ctx context.Context, in *EnsureHubConnectedRequest, opts ...grpc.CallOption) (*OnboardHubResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnboardHubResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_EnsureHubConnected_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) EnsureHubRegistered(ctx context.Context, in *EnsureHubRegisteredRequest, opts ...grpc.CallOption) (*OnboardHubResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnboardHubResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_EnsureHubRegistered_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ResolveHubTrustChallenge(ctx context.Context, in *ResolveHubTrustChallengeRequest, opts ...grpc.CallOption) (*OnboardHubResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnboardHubResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ResolveHubTrustChallenge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetP2PStatus(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*P2PStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(P2PStatus)
	err := c.cc.Invoke(ctx, MobileLogicService_GetP2PStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetP2PSettingsSnapshot(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*P2PSettingsSnapshot, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(P2PSettingsSnapshot)
	err := c.cc.Invoke(ctx, MobileLogicService_GetP2PSettingsSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) StreamP2PStatus(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[P2PStatus], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MobileLogicService_ServiceDesc.Streams[2], MobileLogicService_StreamP2PStatus_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[empty.Empty, P2PStatus]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MobileLogicService_StreamP2PStatusClient = grpc.ServerStreamingClient[P2PStatus]

func (c *mobileLogicServiceClient) SetP2PMode(ctx context.Context, in *SetP2PModeRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileLogicService_SetP2PMode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) LookupIP(ctx context.Context, in *LookupIPRequest, opts ...grpc.CallOption) (*LookupIPResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LookupIPResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_LookupIP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ConfigureGeoIP(ctx context.Context, in *ConfigureGeoIPNodeRequest, opts ...grpc.CallOption) (*proxy.ConfigureGeoIPResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(proxy.ConfigureGeoIPResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ConfigureGeoIP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetGeoIPStatus(ctx context.Context, in *GetGeoIPStatusNodeRequest, opts ...grpc.CallOption) (*proxy.GetGeoIPStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(proxy.GetGeoIPStatusResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_GetGeoIPStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) RestartListeners(ctx context.Context, in *RestartListenersNodeRequest, opts ...grpc.CallOption) (*proxy.RestartListenersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(proxy.RestartListenersResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_RestartListeners_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ListLocalProxyConfigs(ctx context.Context, in *ListLocalProxyConfigsRequest, opts ...grpc.CallOption) (*ListLocalProxyConfigsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLocalProxyConfigsResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ListLocalProxyConfigs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetLocalProxyConfig(ctx context.Context, in *GetLocalProxyConfigRequest, opts ...grpc.CallOption) (*GetLocalProxyConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLocalProxyConfigResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_GetLocalProxyConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ImportLocalProxyConfig(ctx context.Context, in *ImportLocalProxyConfigRequest, opts ...grpc.CallOption) (*ImportLocalProxyConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportLocalProxyConfigResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ImportLocalProxyConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) SaveLocalProxyConfig(ctx context.Context, in *SaveLocalProxyConfigRequest, opts ...grpc.CallOption) (*SaveLocalProxyConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveLocalProxyConfigResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_SaveLocalProxyConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) DeleteLocalProxyConfig(ctx context.Context, in *DeleteLocalProxyConfigRequest, opts ...grpc.CallOption) (*DeleteLocalProxyConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteLocalProxyConfigResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_DeleteLocalProxyConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ValidateLocalProxyConfig(ctx context.Context, in *ValidateLocalProxyConfigRequest, opts ...grpc.CallOption) (*ValidateLocalProxyConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateLocalProxyConfigResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ValidateLocalProxyConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) PushProxyRevision(ctx context.Context, in *PushProxyRevisionRequest, opts ...grpc.CallOption) (*PushProxyRevisionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PushProxyRevisionResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_PushProxyRevision_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) PushLocalProxyRevision(ctx context.Context, in *PushLocalProxyRevisionRequest, opts ...grpc.CallOption) (*PushLocalProxyRevisionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PushLocalProxyRevisionResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_PushLocalProxyRevision_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) PullProxyRevision(ctx context.Context, in *PullProxyRevisionRequest, opts ...grpc.CallOption) (*PullProxyRevisionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PullProxyRevisionResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_PullProxyRevision_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) DiffProxyRevisions(ctx context.Context, in *DiffProxyRevisionsRequest, opts ...grpc.CallOption) (*DiffProxyRevisionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DiffProxyRevisionsResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_DiffProxyRevisions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ListProxyRevisions(ctx context.Context, in *ListProxyRevisionsRequest, opts ...grpc.CallOption) (*ListProxyRevisionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProxyRevisionsResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ListProxyRevisions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) FlushProxyRevisions(ctx context.Context, in *FlushProxyRevisionsRequest, opts ...grpc.CallOption) (*FlushProxyRevisionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FlushProxyRevisionsResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_FlushProxyRevisions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ListProxyConfigs(ctx context.Context, in *ListProxyConfigsRequest, opts ...grpc.CallOption) (*ListProxyConfigsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProxyConfigsResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ListProxyConfigs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) CreateProxyConfig(ctx context.Context, in *CreateProxyConfigRequest, opts ...grpc.CallOption) (*CreateProxyConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateProxyConfigResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_CreateProxyConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) DeleteProxyConfig(ctx context.Context, in *DeleteProxyConfigRequest, opts ...grpc.CallOption) (*DeleteProxyConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteProxyConfigResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_DeleteProxyConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ApplyProxyToNode(ctx context.Context, in *ApplyProxyToNodeRequest, opts ...grpc.CallOption) (*ApplyProxyToNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApplyProxyToNodeResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ApplyProxyToNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) UnapplyProxyFromNode(ctx context.Context, in *UnapplyProxyFromNodeRequest, opts ...grpc.CallOption) (*UnapplyProxyFromNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnapplyProxyFromNodeResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_UnapplyProxyFromNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetAppliedProxies(ctx context.Context, in *GetAppliedProxiesRequest, opts ...grpc.CallOption) (*GetAppliedProxiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAppliedProxiesResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_GetAppliedProxies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) AllowIP(ctx context.Context, in *AllowIPRequest, opts ...grpc.CallOption) (*AllowIPResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AllowIPResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_AllowIP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) StreamMetrics(ctx context.Context, in *StreamMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[NodeMetrics], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MobileLogicService_ServiceDesc.Streams[3], MobileLogicService_StreamMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamMetricsRequest, NodeMetrics]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MobileLogicService_StreamMetricsClient = grpc.ServerStreamingClient[NodeMetrics]

func (c *mobileLogicServiceClient) GetDebugRuntimeStats(ctx context.Context, in *GetDebugRuntimeStatsRequest, opts ...grpc.CallOption) (*DebugRuntimeStats, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DebugRuntimeStats)
	err := c.cc.Invoke(ctx, MobileLogicService_GetDebugRuntimeStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetLogsStats(ctx context.Context, in *GetLogsStatsRequest, opts ...grpc.CallOption) (*GetLogsStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLogsStatsResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_GetLogsStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) ListLogs(ctx context.Context, in *ListLogsRequest, opts ...grpc.CallOption) (*ListLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLogsResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_ListLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) DeleteLogs(ctx context.Context, in *DeleteLogsRequest, opts ...grpc.CallOption) (*DeleteLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteLogsResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_DeleteLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) CleanupOldLogs(ctx context.Context, in *CleanupOldLogsRequest, opts ...grpc.CallOption) (*CleanupOldLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CleanupOldLogsResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_CleanupOldLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) GetNodeFromHub(ctx context.Context, in *GetNodeFromHubRequest, opts ...grpc.CallOption) (*GetNodeFromHubResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNodeFromHubResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_GetNodeFromHub_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileLogicServiceClient) RegisterNodeWithHub(ctx context.Context, in *RegisterNodeWithHubRequest, opts ...grpc.CallOption) (*RegisterNodeWithHubResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterNodeWithHubResponse)
	err := c.cc.Invoke(ctx, MobileLogicService_RegisterNodeWithHub_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MobileLogicServiceServer is the server API for MobileLogicService service.
// All implementations must embed UnimplementedMobileLogicServiceServer
// for forward compatibility.
type MobileLogicServiceServer interface {
	// Initialize the mobile backend with data directory
	Initialize(context.Context, *InitializeRequest) (*InitializeResponse, error)
	// Shutdown the mobile backend gracefully
	Shutdown(context.Context, *empty.Empty) (*empty.Empty, error)
	// Get backend-owned startup state for app routing (setup/auth/ready)
	GetBootstrapState(context.Context, *empty.Empty) (*BootstrapStateResponse, error)
	// Get current identity status
	GetIdentity(context.Context, *empty.Empty) (*IdentityInfo, error)
	// Create new identity with generated mnemonic
	CreateIdentity(context.Context, *CreateIdentityRequest) (*CreateIdentityResponse, error)
	// Restore identity from existing mnemonic
	RestoreIdentity(context.Context, *RestoreIdentityRequest) (*RestoreIdentityResponse, error)
	// Import identity from certificate/key PEM files
	ImportIdentity(context.Context, *ImportIdentityRequest) (*ImportIdentityResponse, error)
	// Unlock identity with passphrase (if encrypted)
	UnlockIdentity(context.Context, *UnlockIdentityRequest) (*UnlockIdentityResponse, error)
	// Lock identity (clear from memory)
	LockIdentity(context.Context, *empty.Empty) (*empty.Empty, error)
	// Change passphrase
	ChangePassphrase(context.Context, *ChangePassphraseRequest) (*empty.Empty, error)
	// Evaluate passphrase strength/policy (backend-owned security logic)
	EvaluatePassphrase(context.Context, *EvaluatePassphraseRequest) (*EvaluatePassphraseResponse, error)
	// Delete identity and all associated data (nodes, settings, templates)
	ResetIdentity(context.Context, *empty.Empty) (*empty.Empty, error)
	// List all paired nodes
	ListNodes(context.Context, *ListNodesRequest) (*ListNodesResponse, error)
	// Get detailed info for a specific node
	GetNode(context.Context, *GetNodeRequest) (*NodeInfo, error)
	// Get node detail snapshot for status/rules/stats surfaces
	GetNodeDetailSnapshot(context.Context, *GetNodeDetailSnapshotRequest) (*NodeDetailSnapshot, error)
	// Update node metadata (name, tags)
	UpdateNode(context.Context, *UpdateNodeRequest) (*NodeInfo, error)
	// Remove/unpair a node
	RemoveNode(context.Context, *RemoveNodeRequest) (*empty.Empty, error)
	// Add a node with direct connection (no Hub required)
	// Used to connect to standalone nitellad admin API
	AddNodeDirect(context.Context, *AddNodeDirectRequest) (*AddNodeDirectResponse, error)
	// Test connection to a direct node
	TestDirectConnection(context.Context, *TestDirectConnectionRequest) (*TestDirectConnectionResponse, error)
	// List proxies on a node
	ListProxies(context.Context, *ListProxiesRequest) (*ListProxiesResponse, error)
	// Get node+proxy snapshot for proxy surfaces
	GetProxiesSnapshot(context.Context, *GetProxiesSnapshotRequest) (*GetProxiesSnapshotResponse, error)
	// Get proxy details
	GetProxy(context.Context, *GetProxyRequest) (*ProxyInfo, error)
	// Create new proxy on node
	AddProxy(context.Context, *AddProxyRequest) (*ProxyInfo, error)
	// Update proxy configuration
	UpdateProxy(context.Context, *UpdateProxyRequest) (*ProxyInfo, error)
	// Enable/disable all proxies on a node in one backend-owned operation
	SetNodeProxiesRunning(context.Context, *SetNodeProxiesRunningRequest) (*SetNodeProxiesRunningResponse, error)
	// Remove proxy from node
	RemoveProxy(context.Context, *RemoveProxyRequest) (*empty.Empty, error)
	// List rules for a proxy
	ListRules(context.Context, *ListRulesRequest) (*ListRulesResponse, error)
	// Get rule details
	GetRule(context.Context, *GetRuleRequest) (*proxy.Rule, error)
	// Add new rule to proxy
	AddRule(context.Context, *AddRuleRequest) (*proxy.Rule, error)
	// Add a quick rule with backend-owned mapping (block/allow/ip/geo shortcuts)
	AddQuickRule(context.Context, *AddQuickRuleRequest) (*AddQuickRuleResponse, error)
	// Update existing rule
	UpdateRule(context.Context, *UpdateRuleRequest) (*proxy.Rule, error)
	// Remove rule from proxy
	RemoveRule(context.Context, *RemoveRuleRequest) (*empty.Empty, error)
	// Block IP address (creates block rule)
	BlockIP(context.Context, *BlockIPRequest) (*BlockIPResponse, error)
	// Block ISP (creates block rule)
	BlockISP(context.Context, *BlockISPRequest) (*BlockISPResponse, error)
	// Block Country (creates block rule)
	BlockCountry(context.Context, *BlockCountryRequest) (*BlockCountryResponse, error)
	// Global Rules (node-level, cross-proxy runtime rules)
	AddGlobalRule(context.Context, *AddGlobalRuleRequest) (*AddGlobalRuleResponse, error)
	ListGlobalRules(context.Context, *ListGlobalRulesRequest) (*ListGlobalRulesResponse, error)
	RemoveGlobalRule(context.Context, *RemoveGlobalRuleRequest) (*RemoveGlobalRuleResponse, error)
	// List pending approval requests (real-time from nodes)
	ListPendingApprovals(context.Context, *ListPendingApprovalsRequest) (*ListPendingApprovalsResponse, error)
	// Get pending + history snapshot for approval center views
	GetApprovalsSnapshot(context.Context, *GetApprovalsSnapshotRequest) (*GetApprovalsSnapshotResponse, error)
	// Approve a connection request
	ApproveRequest(context.Context, *ApproveRequestRequest) (*ApproveRequestResponse, error)
	// Deny a connection request
	DenyRequest(context.Context, *DenyRequestRequest) (*DenyRequestResponse, error)
	// Resolve an approval request (backend-owned approve/deny orchestration)
	ResolveApprovalDecision(context.Context, *ResolveApprovalDecisionRequest) (*ResolveApprovalDecisionResponse, error)
	// Stream approval requests in real-time
	StreamApprovals(*StreamApprovalsRequest, grpc.ServerStreamingServer[ApprovalRequest]) error
	// List approval decision history (backend-owned)
	ListApprovalHistory(context.Context, *ListApprovalHistoryRequest) (*ListApprovalHistoryResponse, error)
	// Clear approval decision history
	ClearApprovalHistory(context.Context, *ClearApprovalHistoryRequest) (*ClearApprovalHistoryResponse, error)
	// Get connection statistics summary
	GetConnectionStats(context.Context, *GetConnectionStatsRequest) (*ConnectionStats, error)
	// List active connections on a node/proxy
	ListConnections(context.Context, *ListConnectionsRequest) (*ListConnectionsResponse, error)
	// Get IP statistics
	GetIPStats(context.Context, *GetIPStatsRequest) (*GetIPStatsResponse, error)
	// Get geo statistics
	GetGeoStats(context.Context, *GetGeoStatsRequest) (*GetGeoStatsResponse, error)
	// Stream connection events
	StreamConnections(*StreamConnectionsRequest, grpc.ServerStreamingServer[ConnectionEvent]) error
	// Close a specific connection
	CloseConnection(context.Context, *CloseConnectionRequest) (*CloseConnectionResponse, error)
	// Close all connections on a proxy
	CloseAllConnections(context.Context, *CloseAllConnectionsRequest) (*CloseAllConnectionsResponse, error)
	// Close all connections across every proxy on a node
	CloseAllNodeConnections(context.Context, *CloseAllNodeConnectionsRequest) (*CloseAllNodeConnectionsResponse, error)
	// Start PAKE pairing session (returns human-readable code)
	StartPairing(context.Context, *StartPairingRequest) (*StartPairingResponse, error)
	// Join existing pairing session using code from node
	JoinPairing(context.Context, *JoinPairingRequest) (*JoinPairingResponse, error)
	// Complete PAKE pairing (after code exchange)
	CompletePairing(context.Context, *CompletePairingRequest) (*CompletePairingResponse, error)
	// Finalize pairing decision (approve/reject) for PAKE or offline QR sessions
	FinalizePairing(context.Context, *FinalizePairingRequest) (*FinalizePairingResponse, error)
	// Cancel ongoing pairing session
	CancelPairing(context.Context, *CancelPairingRequest) (*empty.Empty, error)
	// Generate QR code data for offline pairing
	GenerateQRCode(context.Context, *GenerateQRCodeRequest) (*GenerateQRCodeResponse, error)
	// Scan and process QR code from node
	ScanQRCode(context.Context, *ScanQRCodeRequest) (*ScanQRCodeResponse, error)
	// Generate QR response (signed certificate) for node to scan
	GenerateQRResponse(context.Context, *GenerateQRReplyRequest) (*GenerateQRReplyResponse, error)
	// List available templates
	ListTemplates(context.Context, *ListTemplatesRequest) (*ListTemplatesResponse, error)
	// Get template details
	GetTemplate(context.Context, *GetTemplateRequest) (*Template, error)
	// Create new template from current config
	CreateTemplate(context.Context, *CreateTemplateRequest) (*Template, error)
	// Apply template to a node
	ApplyTemplate(context.Context, *ApplyTemplateRequest) (*ApplyTemplateResponse, error)
	// Delete a template
	DeleteTemplate(context.Context, *DeleteTemplateRequest) (*empty.Empty, error)
	// Sync templates with Hub
	SyncTemplates(context.Context, *empty.Empty) (*SyncTemplatesResponse, error)
	// Export template as YAML (backend-owned format/policy)
	ExportTemplateYaml(context.Context, *ExportTemplateYamlRequest) (*ExportTemplateYamlResponse, error)
	// Import template from YAML (backend-owned parsing/validation)
	ImportTemplateYaml(context.Context, *ImportTemplateYamlRequest) (*ImportTemplateYamlResponse, error)
	// Get current settings
	GetSettings(context.Context, *empty.Empty) (*Settings, error)
	// Get identity + hub + p2p settings snapshot for thin settings surfaces
	GetSettingsOverviewSnapshot(context.Context, *empty.Empty) (*SettingsOverviewSnapshot, error)
	// Update settings
	UpdateSettings(context.Context, *UpdateSettingsRequest) (*Settings, error)
	// Register FCM token for push notifications
	RegisterFCMToken(context.Context, *RegisterFCMTokenRequest) (*empty.Empty, error)
	// Unregister FCM token
	UnregisterFCMToken(context.Context, *empty.Empty) (*empty.Empty, error)
	// Connect to Hub server
	ConnectToHub(context.Context, *ConnectToHubRequest) (*ConnectToHubResponse, error)
	// Disconnect from Hub
	DisconnectFromHub(context.Context, *empty.Empty) (*empty.Empty, error)
	// Get Hub connection status
	GetHubStatus(context.Context, *empty.Empty) (*HubStatus, error)
	// Get hub settings snapshot for settings/onboarding surfaces
	GetHubSettingsSnapshot(context.Context, *empty.Empty) (*HubSettingsSnapshot, error)
	// Get aggregated hub/node overview for thin clients
	GetHubOverview(context.Context, *empty.Empty) (*HubOverview, error)
	// Get hub dashboard snapshot for home/status surfaces
	GetHubDashboardSnapshot(context.Context, *GetHubDashboardSnapshotRequest) (*HubDashboardSnapshot, error)
	// Register user with Hub
	RegisterUser(context.Context, *RegisterUserRequest) (*RegisterUserResponse, error)
	// Fetch Hub's CA certificate for TOFU (Trust On First Use) verification
	FetchHubCA(context.Context, *FetchHubCARequest) (*FetchHubCAResponse, error)
	// Run Hub onboarding flow (connect + optional TOFU + register)
	OnboardHub(context.Context, *OnboardHubRequest) (*OnboardHubResponse, error)
	// Ensure Hub connection using backend-owned defaults/state (no registration)
	EnsureHubConnected(context.Context, *EnsureHubConnectedRequest) (*OnboardHubResponse, error)
	// Ensure Hub registration using backend-owned defaults/state
	EnsureHubRegistered(context.Context, *EnsureHubRegisteredRequest) (*OnboardHubResponse, error)
	// Resolve a pending Hub trust challenge and continue onboarding
	ResolveHubTrustChallenge(context.Context, *ResolveHubTrustChallengeRequest) (*OnboardHubResponse, error)
	// Get current P2P connection status
	GetP2PStatus(context.Context, *empty.Empty) (*P2PStatus, error)
	// Get P2P + settings snapshot for P2P configuration surfaces
	GetP2PSettingsSnapshot(context.Context, *empty.Empty) (*P2PSettingsSnapshot, error)
	// Stream P2P status changes
	StreamP2PStatus(*empty.Empty, grpc.ServerStreamingServer[P2PStatus]) error
	// Set P2P mode (auto, always, disabled)
	SetP2PMode(context.Context, *SetP2PModeRequest) (*empty.Empty, error)
	// Lookup IP geolocation (with cache indicator)
	LookupIP(context.Context, *LookupIPRequest) (*LookupIPResponse, error)
	// Configure GeoIP mode/provider/database for a node
	ConfigureGeoIP(context.Context, *ConfigureGeoIPNodeRequest) (*proxy.ConfigureGeoIPResponse, error)
	// Get GeoIP runtime status for a node
	GetGeoIPStatus(context.Context, *GetGeoIPStatusNodeRequest) (*proxy.GetGeoIPStatusResponse, error)
	// Restart proxy listeners on a node
	RestartListeners(context.Context, *RestartListenersNodeRequest) (*proxy.RestartListenersResponse, error)
	// List proxy configs stored locally on this device
	ListLocalProxyConfigs(context.Context, *ListLocalProxyConfigsRequest) (*ListLocalProxyConfigsResponse, error)
	// Get local proxy config content + metadata
	GetLocalProxyConfig(context.Context, *GetLocalProxyConfigRequest) (*GetLocalProxyConfigResponse, error)
	// Import raw proxy file content into local storage
	ImportLocalProxyConfig(context.Context, *ImportLocalProxyConfigRequest) (*ImportLocalProxyConfigResponse, error)
	// Save/update local proxy config content + metadata
	SaveLocalProxyConfig(context.Context, *SaveLocalProxyConfigRequest) (*SaveLocalProxyConfigResponse, error)
	// Delete a local proxy config
	DeleteLocalProxyConfig(context.Context, *DeleteLocalProxyConfigRequest) (*DeleteLocalProxyConfigResponse, error)
	// Validate local proxy config (checksum/header/YAML/required sections)
	ValidateLocalProxyConfig(context.Context, *ValidateLocalProxyConfigRequest) (*ValidateLocalProxyConfigResponse, error)
	// Push a proxy revision to Hub (encrypt + store)
	PushProxyRevision(context.Context, *PushProxyRevisionRequest) (*PushProxyRevisionResponse, error)
	// Push locally-stored proxy revision to Hub (backend orchestration)
	PushLocalProxyRevision(context.Context, *PushLocalProxyRevisionRequest) (*PushLocalProxyRevisionResponse, error)
	// Pull a proxy revision from Hub (fetch + decrypt)
	PullProxyRevision(context.Context, *PullProxyRevisionRequest) (*PullProxyRevisionResponse, error)
	// Diff local/remote proxy revisions in backend
	DiffProxyRevisions(context.Context, *DiffProxyRevisionsRequest) (*DiffProxyRevisionsResponse, error)
	// List proxy revision history on Hub
	ListProxyRevisions(context.Context, *ListProxyRevisionsRequest) (*ListProxyRevisionsResponse, error)
	// Flush old proxy revisions on Hub
	FlushProxyRevisions(context.Context, *FlushProxyRevisionsRequest) (*FlushProxyRevisionsResponse, error)
	// List proxy configs stored on Hub
	ListProxyConfigs(context.Context, *ListProxyConfigsRequest) (*ListProxyConfigsResponse, error)
	// Create a proxy config entry on Hub
	CreateProxyConfig(context.Context, *CreateProxyConfigRequest) (*CreateProxyConfigResponse, error)
	// Delete a proxy config from Hub
	DeleteProxyConfig(context.Context, *DeleteProxyConfigRequest) (*DeleteProxyConfigResponse, error)
	// Apply a proxy config to a node
	ApplyProxyToNode(context.Context, *ApplyProxyToNodeRequest) (*ApplyProxyToNodeResponse, error)
	// Remove a proxy config from a node
	UnapplyProxyFromNode(context.Context, *UnapplyProxyFromNodeRequest) (*UnapplyProxyFromNodeResponse, error)
	// Get proxies applied on a node
	GetAppliedProxies(context.Context, *GetAppliedProxiesRequest) (*GetAppliedProxiesResponse, error)
	// Allow an IP address (creates allow rule)
	AllowIP(context.Context, *AllowIPRequest) (*AllowIPResponse, error)
	// Stream metrics from a node
	StreamMetrics(*StreamMetricsRequest, grpc.ServerStreamingServer[NodeMetrics]) error
	// Get local runtime debug stats from MobileLogicService process
	GetDebugRuntimeStats(context.Context, *GetDebugRuntimeStatsRequest) (*DebugRuntimeStats, error)
	// Get logs storage statistics
	GetLogsStats(context.Context, *GetLogsStatsRequest) (*GetLogsStatsResponse, error)
	// List logs for a routing token
	ListLogs(context.Context, *ListLogsRequest) (*ListLogsResponse, error)
	// Delete logs
	DeleteLogs(context.Context, *DeleteLogsRequest) (*DeleteLogsResponse, error)
	// Clean up old logs
	CleanupOldLogs(context.Context, *CleanupOldLogsRequest) (*CleanupOldLogsResponse, error)
	// Get node info directly from Hub (not via E2E command)
	GetNodeFromHub(context.Context, *GetNodeFromHubRequest) (*GetNodeFromHubResponse, error)
	// Register a node with Hub using an existing certificate (after PAKE pairing)
	RegisterNodeWithHub(context.Context, *RegisterNodeWithHubRequest) (*RegisterNodeWithHubResponse, error)
	mustEmbedUnimplementedMobileLogicServiceServer()
}

// UnimplementedMobileLogicServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMobileLogicServiceServer struct{}

func (UnimplementedMobileLogicServiceServer) Initialize(context.Context, *InitializeRequest) (*InitializeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Initialize not implemented")
}
func (UnimplementedMobileLogicServiceServer) Shutdown(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method Shutdown not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetBootstrapState(context.Context, *empty.Empty) (*BootstrapStateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBootstrapState not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetIdentity(context.Context, *empty.Empty) (*IdentityInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetIdentity not implemented")
}
func (UnimplementedMobileLogicServiceServer) CreateIdentity(context.Context, *CreateIdentityRequest) (*CreateIdentityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateIdentity not implemented")
}
func (UnimplementedMobileLogicServiceServer) RestoreIdentity(context.Context, *RestoreIdentityRequest) (*RestoreIdentityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RestoreIdentity not implemented")
}
func (UnimplementedMobileLogicServiceServer) ImportIdentity(context.Context, *ImportIdentityRequest) (*ImportIdentityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ImportIdentity not implemented")
}
func (UnimplementedMobileLogicServiceServer) UnlockIdentity(context.Context, *UnlockIdentityRequest) (*UnlockIdentityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UnlockIdentity not implemented")
}
func (UnimplementedMobileLogicServiceServer) LockIdentity(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method LockIdentity not implemented")
}
func (UnimplementedMobileLogicServiceServer) ChangePassphrase(context.Context, *ChangePassphraseRequest) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ChangePassphrase not implemented")
}
func (UnimplementedMobileLogicServiceServer) EvaluatePassphrase(context.Context, *EvaluatePassphraseRequest) (*EvaluatePassphraseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EvaluatePassphrase not implemented")
}
func (UnimplementedMobileLogicServiceServer) ResetIdentity(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ResetIdentity not implemented")
}
func (UnimplementedMobileLogicServiceServer) ListNodes(context.Context, *ListNodesRequest) (*ListNodesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListNodes not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetNode(context.Context, *GetNodeRequest) (*NodeInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNode not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetNodeDetailSnapshot(context.Context, *GetNodeDetailSnapshotRequest) (*NodeDetailSnapshot, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNodeDetailSnapshot not implemented")
}
func (UnimplementedMobileLogicServiceServer) UpdateNode(context.Context, *UpdateNodeRequest) (*NodeInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateNode not implemented")
}
func (UnimplementedMobileLogicServiceServer) RemoveNode(context.Context, *RemoveNodeRequest) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveNode not implemented")
}
func (UnimplementedMobileLogicServiceServer) AddNodeDirect(context.Context, *AddNodeDirectRequest) (*AddNodeDirectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddNodeDirect not implemented")
}
func (UnimplementedMobileLogicServiceServer) TestDirectConnection(context.Context, *TestDirectConnectionRequest) (*TestDirectConnectionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TestDirectConnection not implemented")
}
func (UnimplementedMobileLogicServiceServer) ListProxies(context.Context, *ListProxiesRequest) (*ListProxiesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListProxies not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetProxiesSnapshot(context.Context, *GetProxiesSnapshotRequest) (*GetProxiesSnapshotResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetProxiesSnapshot not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetProxy(context.Context, *GetProxyRequest) (*ProxyInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetProxy not implemented")
}
func (UnimplementedMobileLogicServiceServer) AddProxy(context.Context, *AddProxyRequest) (*ProxyInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method AddProxy not implemented")
}
func (UnimplementedMobileLogicServiceServer) UpdateProxy(context.Context, *UpdateProxyRequest) (*ProxyInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateProxy not implemented")
}
func (UnimplementedMobileLogicServiceServer) SetNodeProxiesRunning(context.Context, *SetNodeProxiesRunningRequest) (*SetNodeProxiesRunningResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetNodeProxiesRunning not implemented")
}
func (UnimplementedMobileLogicServiceServer) RemoveProxy(context.Context, *RemoveProxyRequest) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveProxy not implemented")
}
func (UnimplementedMobileLogicServiceServer) ListRules(context.Context, *ListRulesRequest) (*ListRulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListRules not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetRule(context.Context, *GetRuleRequest) (*proxy.Rule, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRule not implemented")
}
func (UnimplementedMobileLogicServiceServer) AddRule(context.Context, *AddRuleRequest) (*proxy.Rule, error) {
	return nil, status.Error(codes.Unimplemented, "method AddRule not implemented")
}
func (UnimplementedMobileLogicServiceServer) AddQuickRule(context.Context, *AddQuickRuleRequest) (*AddQuickRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddQuickRule not implemented")
}
func (UnimplementedMobileLogicServiceServer) UpdateRule(context.Context, *UpdateRuleRequest) (*proxy.Rule, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateRule not implemented")
}
func (UnimplementedMobileLogicServiceServer) RemoveRule(context.Context, *RemoveRuleRequest) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveRule not implemented")
}
func (UnimplementedMobileLogicServiceServer) BlockIP(context.Context, *BlockIPRequest) (*BlockIPResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BlockIP not implemented")
}
func (UnimplementedMobileLogicServiceServer) BlockISP(context.Context, *BlockISPRequest) (*BlockISPResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BlockISP not implemented")
}
func (UnimplementedMobileLogicServiceServer) BlockCountry(context.Context, *BlockCountryRequest) (*BlockCountryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BlockCountry not implemented")
}
func (UnimplementedMobileLogicServiceServer) AddGlobalRule(context.Context, *AddGlobalRuleRequest) (*AddGlobalRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddGlobalRule not implemented")
}
func (UnimplementedMobileLogicServiceServer) ListGlobalRules(context.Context, *ListGlobalRulesRequest) (*ListGlobalRulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListGlobalRules not implemented")
}
func (UnimplementedMobileLogicServiceServer) RemoveGlobalRule(context.Context, *RemoveGlobalRuleRequest) (*RemoveGlobalRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveGlobalRule not implemented")
}
func (UnimplementedMobileLogicServiceServer) ListPendingApprovals(context.Context, *ListPendingApprovalsRequest) (*ListPendingApprovalsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPendingApprovals not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetApprovalsSnapshot(context.Context, *GetApprovalsSnapshotRequest) (*GetApprovalsSnapshotResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetApprovalsSnapshot not implemented")
}
func (UnimplementedMobileLogicServiceServer) ApproveRequest(context.Context, *ApproveRequestRequest) (*ApproveRequestResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ApproveRequest not implemented")
}
func (UnimplementedMobileLogicServiceServer) DenyRequest(context.Context, *DenyRequestRequest) (*DenyRequestResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DenyRequest not implemented")
}
func (UnimplementedMobileLogicServiceServer) ResolveApprovalDecision(context.Context, *ResolveApprovalDecisionRequest) (*ResolveApprovalDecisionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResolveApprovalDecision not implemented")
}
func (UnimplementedMobileLogicServiceServer) StreamApprovals(*StreamApprovalsRequest, grpc.ServerStreamingServer[ApprovalRequest]) error {
	return status.Error(codes.Unimplemented, "method StreamApprovals not implemented")
}
func (UnimplementedMobileLogicServiceServer) ListApprovalHistory(context.Context, *ListApprovalHistoryRequest) (*ListApprovalHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListApprovalHistory not implemented")
}
func (UnimplementedMobileLogicServiceServer) ClearApprovalHistory(context.Context, *ClearApprovalHistoryRequest) (*ClearApprovalHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClearApprovalHistory not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetConnectionStats(context.Context, *GetConnectionStatsRequest) (*ConnectionStats, error) {
	return nil, status.Error(codes.Unimplemented, "method GetConnectionStats not implemented")
}
func (UnimplementedMobileLogicServiceServer) ListConnections(context.Context, *ListConnectionsRequest) (*ListConnectionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListConnections not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetIPStats(context.Context, *GetIPStatsRequest) (*GetIPStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetIPStats not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetGeoStats(context.Context, *GetGeoStatsRequest) (*GetGeoStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGeoStats not implemented")
}
func (UnimplementedMobileLogicServiceServer) StreamConnections(*StreamConnectionsRequest, grpc.ServerStreamingServer[ConnectionEvent]) error {
	return status.Error(codes.Unimplemented, "method StreamConnections not implemented")
}
func (UnimplementedMobileLogicServiceServer) CloseConnection(context.Context, *CloseConnectionRequest) (*CloseConnectionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CloseConnection not implemented")
}
func (UnimplementedMobileLogicServiceServer) CloseAllConnections(context.Context, *CloseAllConnectionsRequest) (*CloseAllConnectionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CloseAllConnections not implemented")
}
func (UnimplementedMobileLogicServiceServer) CloseAllNodeConnections(context.Context, *CloseAllNodeConnectionsRequest) (*CloseAllNodeConnectionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CloseAllNodeConnections not implemented")
}
func (UnimplementedMobileLogicServiceServer) StartPairing(context.Context, *StartPairingRequest) (*StartPairingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartPairing not implemented")
}
func (UnimplementedMobileLogicServiceServer) JoinPairing(context.Context, *JoinPairingRequest) (*JoinPairingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method JoinPairing not implemented")
}
func (UnimplementedMobileLogicServiceServer) CompletePairing(context.Context, *CompletePairingRequest) (*CompletePairingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CompletePairing not implemented")
}
func (UnimplementedMobileLogicServiceServer) FinalizePairing(context.Context, *FinalizePairingRequest) (*FinalizePairingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FinalizePairing not implemented")
}
func (UnimplementedMobileLogicServiceServer) CancelPairing(context.Context, *CancelPairingRequest) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method CancelPairing not implemented")
}
func (UnimplementedMobileLogicServiceServer) GenerateQRCode(context.Context, *GenerateQRCodeRequest) (*GenerateQRCodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GenerateQRCode not implemented")
}
func (UnimplementedMobileLogicServiceServer) ScanQRCode(context.Context, *ScanQRCodeRequest) (*ScanQRCodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ScanQRCode not implemented")
}
func (UnimplementedMobileLogicServiceServer) GenerateQRResponse(context.Context, *GenerateQRReplyRequest) (*GenerateQRReplyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GenerateQRResponse not implemented")
}
func (UnimplementedMobileLogicServiceServer) ListTemplates(context.Context, *ListTemplatesRequest) (*ListTemplatesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTemplates not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetTemplate(context.Context, *GetTemplateRequest) (*Template, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTemplate not implemented")
}
func (UnimplementedMobileLogicServiceServer) CreateTemplate(context.Context, *CreateTemplateRequest) (*Template, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateTemplate not implemented")
}
func (UnimplementedMobileLogicServiceServer) ApplyTemplate(context.Context, *ApplyTemplateRequest) (*ApplyTemplateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ApplyTemplate not implemented")
}
func (UnimplementedMobileLogicServiceServer) DeleteTemplate(context.Context, *DeleteTemplateRequest) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteTemplate not implemented")
}
func (UnimplementedMobileLogicServiceServer) SyncTemplates(context.Context, *empty.Empty) (*SyncTemplatesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SyncTemplates not implemented")
}
func (UnimplementedMobileLogicServiceServer) ExportTemplateYaml(context.Context, *ExportTemplateYamlRequest) (*ExportTemplateYamlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExportTemplateYaml not implemented")
}
func (UnimplementedMobileLogicServiceServer) ImportTemplateYaml(context.Context, *ImportTemplateYamlRequest) (*ImportTemplateYamlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ImportTemplateYaml not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetSettings(context.Context, *empty.Empty) (*Settings, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSettings not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetSettingsOverviewSnapshot(context.Context, *empty.Empty) (*SettingsOverviewSnapshot, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSettingsOverviewSnapshot not implemented")
}
func (UnimplementedMobileLogicServiceServer) UpdateSettings(context.Context, *UpdateSettingsRequest) (*Settings, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSettings not implemented")
}
func (UnimplementedMobileLogicServiceServer) RegisterFCMToken(context.Context, *RegisterFCMTokenRequest) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterFCMToken not implemented")
}
func (UnimplementedMobileLogicServiceServer) UnregisterFCMToken(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method UnregisterFCMToken not implemented")
}
func (UnimplementedMobileLogicServiceServer) ConnectToHub(context.Context, *ConnectToHubRequest) (*ConnectToHubResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ConnectToHub not implemented")
}
func (UnimplementedMobileLogicServiceServer) DisconnectFromHub(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DisconnectFromHub not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetHubStatus(context.Context, *empty.Empty) (*HubStatus, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHubStatus not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetHubSettingsSnapshot(context.Context, *empty.Empty) (*HubSettingsSnapshot, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHubSettingsSnapshot not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetHubOverview(context.Context, *empty.Empty) (*HubOverview, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHubOverview not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetHubDashboardSnapshot(context.Context, *GetHubDashboardSnapshotRequest) (*HubDashboardSnapshot, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHubDashboardSnapshot not implemented")
}
func (UnimplementedMobileLogicServiceServer) RegisterUser(context.Context, *RegisterUserRequest) (*RegisterUserResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterUser not implemented")
}
func (UnimplementedMobileLogicServiceServer) FetchHubCA(context.Context, *FetchHubCARequest) (*FetchHubCAResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FetchHubCA not implemented")
}
func (UnimplementedMobileLogicServiceServer) OnboardHub(context.Context, *OnboardHubRequest) (*OnboardHubResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method OnboardHub not implemented")
}
func (UnimplementedMobileLogicServiceServer) EnsureHubConnected(context.Context, *EnsureHubConnectedRequest) (*OnboardHubResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EnsureHubConnected not implemented")
}
func (UnimplementedMobileLogicServiceServer) EnsureHubRegistered(context.Context, *EnsureHubRegisteredRequest) (*OnboardHubResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EnsureHubRegistered not implemented")
}
func (UnimplementedMobileLogicServiceServer) ResolveHubTrustChallenge(context.Context, *ResolveHubTrustChallengeRequest) (*OnboardHubResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResolveHubTrustChallenge not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetP2PStatus(context.Context, *empty.Empty) (*P2PStatus, error) {
	return nil, status.Error(codes.Unimplemented, "method GetP2PStatus not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetP2PSettingsSnapshot(context.Context, *empty.Empty) (*P2PSettingsSnapshot, error) {
	return nil, status.Error(codes.Unimplemented, "method GetP2PSettingsSnapshot not implemented")
}
func (UnimplementedMobileLogicServiceServer) StreamP2PStatus(*empty.Empty, grpc.ServerStreamingServer[P2PStatus]) error {
	return status.Error(codes.Unimplemented, "method StreamP2PStatus not implemented")
}
func (UnimplementedMobileLogicServiceServer) SetP2PMode(context.Context, *SetP2PModeRequest) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method SetP2PMode not implemented")
}
func (UnimplementedMobileLogicServiceServer) LookupIP(context.Context, *LookupIPRequest) (*LookupIPResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LookupIP not implemented")
}
func (UnimplementedMobileLogicServiceServer) ConfigureGeoIP(context.Context, *ConfigureGeoIPNodeRequest) (*proxy.ConfigureGeoIPResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ConfigureGeoIP not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetGeoIPStatus(context.Context, *GetGeoIPStatusNodeRequest) (*proxy.GetGeoIPStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGeoIPStatus not implemented")
}
func (UnimplementedMobileLogicServiceServer) RestartListeners(context.Context, *RestartListenersNodeRequest) (*proxy.RestartListenersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RestartListeners not implemented")
}
func (UnimplementedMobileLogicServiceServer) ListLocalProxyConfigs(context.Context, *ListLocalProxyConfigsRequest) (*ListLocalProxyConfigsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListLocalProxyConfigs not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetLocalProxyConfig(context.Context, *GetLocalProxyConfigRequest) (*GetLocalProxyConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLocalProxyConfig not implemented")
}
func (UnimplementedMobileLogicServiceServer) ImportLocalProxyConfig(context.Context, *ImportLocalProxyConfigRequest) (*ImportLocalProxyConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ImportLocalProxyConfig not implemented")
}
func (UnimplementedMobileLogicServiceServer) SaveLocalProxyConfig(context.Context, *SaveLocalProxyConfigRequest) (*SaveLocalProxyConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveLocalProxyConfig not implemented")
}
func (UnimplementedMobileLogicServiceServer) DeleteLocalProxyConfig(context.Context, *DeleteLocalProxyConfigRequest) (*DeleteLocalProxyConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteLocalProxyConfig not implemented")
}
func (UnimplementedMobileLogicServiceServer) ValidateLocalProxyConfig(context.Context, *ValidateLocalProxyConfigRequest) (*ValidateLocalProxyConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateLocalProxyConfig not implemented")
}
func (UnimplementedMobileLogicServiceServer) PushProxyRevision(context.Context, *PushProxyRevisionRequest) (*PushProxyRevisionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PushProxyRevision not implemented")
}
func (UnimplementedMobileLogicServiceServer) PushLocalProxyRevision(context.Context, *PushLocalProxyRevisionRequest) (*PushLocalProxyRevisionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PushLocalProxyRevision not implemented")
}
func (UnimplementedMobileLogicServiceServer) PullProxyRevision(context.Context, *PullProxyRevisionRequest) (*PullProxyRevisionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PullProxyRevision not implemented")
}
func (UnimplementedMobileLogicServiceServer) DiffProxyRevisions(context.Context, *DiffProxyRevisionsRequest) (*DiffProxyRevisionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DiffProxyRevisions not implemented")
}
func (UnimplementedMobileLogicServiceServer) ListProxyRevisions(context.Context, *ListProxyRevisionsRequest) (*ListProxyRevisionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListProxyRevisions not implemented")
}
func (UnimplementedMobileLogicServiceServer) FlushProxyRevisions(context.Context, *FlushProxyRevisionsRequest) (*FlushProxyRevisionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FlushProxyRevisions not implemented")
}
func (UnimplementedMobileLogicServiceServer) ListProxyConfigs(context.Context, *ListProxyConfigsRequest) (*ListProxyConfigsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListProxyConfigs not implemented")
}
func (UnimplementedMobileLogicServiceServer) CreateProxyConfig(context.Context, *CreateProxyConfigRequest) (*CreateProxyConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateProxyConfig not implemented")
}
func (UnimplementedMobileLogicServiceServer) DeleteProxyConfig(context.Context, *DeleteProxyConfigRequest) (*DeleteProxyConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteProxyConfig not implemented")
}
func (UnimplementedMobileLogicServiceServer) ApplyProxyToNode(context.Context, *ApplyProxyToNodeRequest) (*ApplyProxyToNodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ApplyProxyToNode not implemented")
}
func (UnimplementedMobileLogicServiceServer) UnapplyProxyFromNode(context.Context, *UnapplyProxyFromNodeRequest) (*UnapplyProxyFromNodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UnapplyProxyFromNode not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetAppliedProxies(context.Context, *GetAppliedProxiesRequest) (*GetAppliedProxiesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAppliedProxies not implemented")
}
func (UnimplementedMobileLogicServiceServer) AllowIP(context.Context, *AllowIPRequest) (*AllowIPResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AllowIP not implemented")
}
func (UnimplementedMobileLogicServiceServer) StreamMetrics(*StreamMetricsRequest, grpc.ServerStreamingServer[NodeMetrics]) error {
	return status.Error(codes.Unimplemented, "method StreamMetrics not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetDebugRuntimeStats(context.Context, *GetDebugRuntimeStatsRequest) (*DebugRuntimeStats, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDebugRuntimeStats not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetLogsStats(context.Context, *GetLogsStatsRequest) (*GetLogsStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLogsStats not implemented")
}
func (UnimplementedMobileLogicServiceServer) ListLogs(context.Context, *ListLogsRequest) (*ListLogsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListLogs not implemented")
}
func (UnimplementedMobileLogicServiceServer) DeleteLogs(context.Context, *DeleteLogsRequest) (*DeleteLogsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteLogs not implemented")
}
func (UnimplementedMobileLogicServiceServer) CleanupOldLogs(context.Context, *CleanupOldLogsRequest) (*CleanupOldLogsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CleanupOldLogs not implemented")
}
func (UnimplementedMobileLogicServiceServer) GetNodeFromHub(context.Context, *GetNodeFromHubRequest) (*GetNodeFromHubResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNodeFromHub not implemented")
}
func (UnimplementedMobileLogicServiceServer) RegisterNodeWithHub(context.Context, *RegisterNodeWithHubRequest) (*RegisterNodeWithHubResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterNodeWithHub not implemented")
}
func (UnimplementedMobileLogicServiceServer) mustEmbedUnimplementedMobileLogicServiceServer() {}
func (UnimplementedMobileLogicServiceServer) testEmbeddedByValue()                            {}

// UnsafeMobileLogicServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MobileLogicServiceServer will
// result in compilation errors.
type UnsafeMobileLogicServiceServer interface {
	mustEmbedUnimplementedMobileLogicServiceServer()
}

func RegisterMobileLogicServiceServer(s grpc.ServiceRegistrar, srv MobileLogicServiceServer) {
	// If the following call panics, it indicates UnimplementedMobileLogicServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MobileLogicService_ServiceDesc, srv)
}

func _MobileLogicService_Initialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitializeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).Initialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_Initialize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).Initialize(ctx, req.(*InitializeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_Shutdown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).Shutdown(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetBootstrapState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetBootstrapState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetBootstrapState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetBootstrapState(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetIdentity(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_CreateIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).CreateIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_CreateIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).CreateIdentity(ctx, req.(*CreateIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_RestoreIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).RestoreIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_RestoreIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).RestoreIdentity(ctx, req.(*RestoreIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ImportIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ImportIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ImportIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ImportIdentity(ctx, req.(*ImportIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_UnlockIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).UnlockIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_UnlockIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).UnlockIdentity(ctx, req.(*UnlockIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_LockIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).LockIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_LockIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).LockIdentity(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ChangePassphrase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangePassphraseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ChangePassphrase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ChangePassphrase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ChangePassphrase(ctx, req.(*ChangePassphraseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_EvaluatePassphrase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvaluatePassphraseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).EvaluatePassphrase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_EvaluatePassphrase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).EvaluatePassphrase(ctx, req.(*EvaluatePassphraseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ResetIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ResetIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ResetIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ResetIdentity(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ListNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ListNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ListNodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ListNodes(ctx, req.(*ListNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetNode(ctx, req.(*GetNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetNodeDetailSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeDetailSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetNodeDetailSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetNodeDetailSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetNodeDetailSnapshot(ctx, req.(*GetNodeDetailSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_UpdateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).UpdateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_UpdateNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).UpdateNode(ctx, req.(*UpdateNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_RemoveNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).RemoveNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_RemoveNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).RemoveNode(ctx, req.(*RemoveNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_AddNodeDirect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddNodeDirectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).AddNodeDirect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_AddNodeDirect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).AddNodeDirect(ctx, req.(*AddNodeDirectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_TestDirectConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestDirectConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).TestDirectConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_TestDirectConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).TestDirectConnection(ctx, req.(*TestDirectConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ListProxies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProxiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ListProxies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ListProxies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ListProxies(ctx, req.(*ListProxiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetProxiesSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProxiesSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetProxiesSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetProxiesSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetProxiesSnapshot(ctx, req.(*GetProxiesSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetProxy(ctx, req.(*GetProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_AddProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).AddProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_AddProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).AddProxy(ctx, req.(*AddProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_UpdateProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).UpdateProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_UpdateProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).UpdateProxy(ctx, req.(*UpdateProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_SetNodeProxiesRunning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetNodeProxiesRunningRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).SetNodeProxiesRunning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_SetNodeProxiesRunning_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).SetNodeProxiesRunning(ctx, req.(*SetNodeProxiesRunningRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_RemoveProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).RemoveProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_RemoveProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).RemoveProxy(ctx, req.(*RemoveProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ListRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ListRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ListRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ListRules(ctx, req.(*ListRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetRule(ctx, req.(*GetRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_AddRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).AddRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_AddRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).AddRule(ctx, req.(*AddRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_AddQuickRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddQuickRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).AddQuickRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_AddQuickRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).AddQuickRule(ctx, req.(*AddQuickRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_UpdateRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).UpdateRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_UpdateRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).UpdateRule(ctx, req.(*UpdateRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_RemoveRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).RemoveRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_RemoveRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).RemoveRule(ctx, req.(*RemoveRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_BlockIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockIPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).BlockIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_BlockIP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).BlockIP(ctx, req.(*BlockIPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_BlockISP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockISPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).BlockISP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_BlockISP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).BlockISP(ctx, req.(*BlockISPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_BlockCountry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockCountryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).BlockCountry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_BlockCountry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).BlockCountry(ctx, req.(*BlockCountryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_AddGlobalRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddGlobalRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).AddGlobalRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_AddGlobalRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).AddGlobalRule(ctx, req.(*AddGlobalRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ListGlobalRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGlobalRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ListGlobalRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ListGlobalRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ListGlobalRules(ctx, req.(*ListGlobalRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_RemoveGlobalRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveGlobalRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).RemoveGlobalRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_RemoveGlobalRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).RemoveGlobalRule(ctx, req.(*RemoveGlobalRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ListPendingApprovals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPendingApprovalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ListPendingApprovals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ListPendingApprovals_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ListPendingApprovals(ctx, req.(*ListPendingApprovalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetApprovalsSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetApprovalsSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetApprovalsSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetApprovalsSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetApprovalsSnapshot(ctx, req.(*GetApprovalsSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ApproveRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ApproveRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ApproveRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ApproveRequest(ctx, req.(*ApproveRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_DenyRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DenyRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).DenyRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_DenyRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).DenyRequest(ctx, req.(*DenyRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ResolveApprovalDecision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveApprovalDecisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ResolveApprovalDecision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ResolveApprovalDecision_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ResolveApprovalDecision(ctx, req.(*ResolveApprovalDecisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_StreamApprovals_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamApprovalsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MobileLogicServiceServer).StreamApprovals(m, &grpc.GenericServerStream[StreamApprovalsRequest, ApprovalRequest]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MobileLogicService_StreamApprovalsServer = grpc.ServerStreamingServer[ApprovalRequest]

func _MobileLogicService_ListApprovalHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListApprovalHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ListApprovalHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ListApprovalHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ListApprovalHistory(ctx, req.(*ListApprovalHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ClearApprovalHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearApprovalHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ClearApprovalHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ClearApprovalHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ClearApprovalHistory(ctx, req.(*ClearApprovalHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetConnectionStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConnectionStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetConnectionStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetConnectionStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetConnectionStats(ctx, req.(*GetConnectionStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ListConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConnectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ListConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ListConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ListConnections(ctx, req.(*ListConnectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetIPStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIPStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetIPStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetIPStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetIPStats(ctx, req.(*GetIPStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetGeoStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGeoStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetGeoStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetGeoStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetGeoStats(ctx, req.(*GetGeoStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_StreamConnections_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamConnectionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MobileLogicServiceServer).StreamConnections(m, &grpc.GenericServerStream[StreamConnectionsRequest, ConnectionEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MobileLogicService_StreamConnectionsServer = grpc.ServerStreamingServer[ConnectionEvent]

func _MobileLogicService_CloseConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).CloseConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_CloseConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).CloseConnection(ctx, req.(*CloseConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_CloseAllConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseAllConnectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).CloseAllConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_CloseAllConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).CloseAllConnections(ctx, req.(*CloseAllConnectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_CloseAllNodeConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseAllNodeConnectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).CloseAllNodeConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_CloseAllNodeConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).CloseAllNodeConnections(ctx, req.(*CloseAllNodeConnectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_StartPairing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartPairingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).StartPairing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_StartPairing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).StartPairing(ctx, req.(*StartPairingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_JoinPairing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinPairingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).JoinPairing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_JoinPairing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).JoinPairing(ctx, req.(*JoinPairingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_CompletePairing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompletePairingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).CompletePairing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_CompletePairing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).CompletePairing(ctx, req.(*CompletePairingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_FinalizePairing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinalizePairingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).FinalizePairing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_FinalizePairing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).FinalizePairing(ctx, req.(*FinalizePairingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_CancelPairing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelPairingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).CancelPairing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_CancelPairing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).CancelPairing(ctx, req.(*CancelPairingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GenerateQRCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateQRCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GenerateQRCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GenerateQRCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GenerateQRCode(ctx, req.(*GenerateQRCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ScanQRCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScanQRCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ScanQRCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ScanQRCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ScanQRCode(ctx, req.(*ScanQRCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GenerateQRResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateQRReplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GenerateQRResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GenerateQRResponse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GenerateQRResponse(ctx, req.(*GenerateQRReplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ListTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTemplatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ListTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ListTemplates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ListTemplates(ctx, req.(*ListTemplatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetTemplate(ctx, req.(*GetTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_CreateTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).CreateTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_CreateTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).CreateTemplate(ctx, req.(*CreateTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ApplyTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ApplyTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ApplyTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ApplyTemplate(ctx, req.(*ApplyTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_DeleteTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).DeleteTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_DeleteTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).DeleteTemplate(ctx, req.(*DeleteTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_SyncTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).SyncTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_SyncTemplates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).SyncTemplates(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ExportTemplateYaml_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportTemplateYamlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ExportTemplateYaml(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ExportTemplateYaml_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ExportTemplateYaml(ctx, req.(*ExportTemplateYamlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ImportTemplateYaml_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportTemplateYamlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ImportTemplateYaml(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ImportTemplateYaml_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ImportTemplateYaml(ctx, req.(*ImportTemplateYamlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetSettings(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetSettingsOverviewSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetSettingsOverviewSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetSettingsOverviewSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetSettingsOverviewSnapshot(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_UpdateSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).UpdateSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_UpdateSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).UpdateSettings(ctx, req.(*UpdateSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_RegisterFCMToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterFCMTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).RegisterFCMToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_RegisterFCMToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).RegisterFCMToken(ctx, req.(*RegisterFCMTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_UnregisterFCMToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).UnregisterFCMToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_UnregisterFCMToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).UnregisterFCMToken(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ConnectToHub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectToHubRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ConnectToHub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ConnectToHub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ConnectToHub(ctx, req.(*ConnectToHubRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_DisconnectFromHub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).DisconnectFromHub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_DisconnectFromHub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).DisconnectFromHub(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetHubStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetHubStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetHubStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetHubStatus(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetHubSettingsSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetHubSettingsSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetHubSettingsSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetHubSettingsSnapshot(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetHubOverview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetHubOverview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetHubOverview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetHubOverview(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetHubDashboardSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHubDashboardSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetHubDashboardSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetHubDashboardSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetHubDashboardSnapshot(ctx, req.(*GetHubDashboardSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_RegisterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).RegisterUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_RegisterUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).RegisterUser(ctx, req.(*RegisterUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_FetchHubCA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchHubCARequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).FetchHubCA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_FetchHubCA_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).FetchHubCA(ctx, req.(*FetchHubCARequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_OnboardHub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnboardHubRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).OnboardHub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_OnboardHub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).OnboardHub(ctx, req.(*OnboardHubRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_EnsureHubConnected_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnsureHubConnectedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).EnsureHubConnected(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_EnsureHubConnected_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).EnsureHubConnected(ctx, req.(*EnsureHubConnectedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_EnsureHubRegistered_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnsureHubRegisteredRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).EnsureHubRegistered(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_EnsureHubRegistered_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).EnsureHubRegistered(ctx, req.(*EnsureHubRegisteredRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ResolveHubTrustChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveHubTrustChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ResolveHubTrustChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ResolveHubTrustChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ResolveHubTrustChallenge(ctx, req.(*ResolveHubTrustChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetP2PStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetP2PStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetP2PStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetP2PStatus(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetP2PSettingsSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetP2PSettingsSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetP2PSettingsSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetP2PSettingsSnapshot(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_StreamP2PStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(empty.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MobileLogicServiceServer).StreamP2PStatus(m, &grpc.GenericServerStream[empty.Empty, P2PStatus]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MobileLogicService_StreamP2PStatusServer = grpc.ServerStreamingServer[P2PStatus]

func _MobileLogicService_SetP2PMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetP2PModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).SetP2PMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_SetP2PMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).SetP2PMode(ctx, req.(*SetP2PModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_LookupIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupIPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).LookupIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_LookupIP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).LookupIP(ctx, req.(*LookupIPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ConfigureGeoIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureGeoIPNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ConfigureGeoIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ConfigureGeoIP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ConfigureGeoIP(ctx, req.(*ConfigureGeoIPNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetGeoIPStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGeoIPStatusNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetGeoIPStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetGeoIPStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetGeoIPStatus(ctx, req.(*GetGeoIPStatusNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_RestartListeners_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestartListenersNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).RestartListeners(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_RestartListeners_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).RestartListeners(ctx, req.(*RestartListenersNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ListLocalProxyConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLocalProxyConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ListLocalProxyConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ListLocalProxyConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ListLocalProxyConfigs(ctx, req.(*ListLocalProxyConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetLocalProxyConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLocalProxyConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetLocalProxyConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetLocalProxyConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetLocalProxyConfig(ctx, req.(*GetLocalProxyConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ImportLocalProxyConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportLocalProxyConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ImportLocalProxyConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ImportLocalProxyConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ImportLocalProxyConfig(ctx, req.(*ImportLocalProxyConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_SaveLocalProxyConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveLocalProxyConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).SaveLocalProxyConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_SaveLocalProxyConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).SaveLocalProxyConfig(ctx, req.(*SaveLocalProxyConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_DeleteLocalProxyConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLocalProxyConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).DeleteLocalProxyConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_DeleteLocalProxyConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).DeleteLocalProxyConfig(ctx, req.(*DeleteLocalProxyConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ValidateLocalProxyConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateLocalProxyConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ValidateLocalProxyConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ValidateLocalProxyConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ValidateLocalProxyConfig(ctx, req.(*ValidateLocalProxyConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_PushProxyRevision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushProxyRevisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).PushProxyRevision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_PushProxyRevision_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).PushProxyRevision(ctx, req.(*PushProxyRevisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_PushLocalProxyRevision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushLocalProxyRevisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).PushLocalProxyRevision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_PushLocalProxyRevision_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).PushLocalProxyRevision(ctx, req.(*PushLocalProxyRevisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_PullProxyRevision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullProxyRevisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).PullProxyRevision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_PullProxyRevision_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).PullProxyRevision(ctx, req.(*PullProxyRevisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_DiffProxyRevisions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiffProxyRevisionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).DiffProxyRevisions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_DiffProxyRevisions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).DiffProxyRevisions(ctx, req.(*DiffProxyRevisionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ListProxyRevisions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProxyRevisionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ListProxyRevisions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ListProxyRevisions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ListProxyRevisions(ctx, req.(*ListProxyRevisionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_FlushProxyRevisions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlushProxyRevisionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).FlushProxyRevisions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_FlushProxyRevisions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).FlushProxyRevisions(ctx, req.(*FlushProxyRevisionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ListProxyConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProxyConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ListProxyConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ListProxyConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ListProxyConfigs(ctx, req.(*ListProxyConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_CreateProxyConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProxyConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).CreateProxyConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_CreateProxyConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).CreateProxyConfig(ctx, req.(*CreateProxyConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_DeleteProxyConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProxyConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).DeleteProxyConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_DeleteProxyConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).DeleteProxyConfig(ctx, req.(*DeleteProxyConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ApplyProxyToNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyProxyToNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ApplyProxyToNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ApplyProxyToNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ApplyProxyToNode(ctx, req.(*ApplyProxyToNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_UnapplyProxyFromNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnapplyProxyFromNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).UnapplyProxyFromNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_UnapplyProxyFromNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).UnapplyProxyFromNode(ctx, req.(*UnapplyProxyFromNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetAppliedProxies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppliedProxiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetAppliedProxies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetAppliedProxies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetAppliedProxies(ctx, req.(*GetAppliedProxiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_AllowIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllowIPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).AllowIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_AllowIP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).AllowIP(ctx, req.(*AllowIPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_StreamMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamMetricsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MobileLogicServiceServer).StreamMetrics(m, &grpc.GenericServerStream[StreamMetricsRequest, NodeMetrics]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MobileLogicService_StreamMetricsServer = grpc.ServerStreamingServer[NodeMetrics]

func _MobileLogicService_GetDebugRuntimeStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDebugRuntimeStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetDebugRuntimeStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetDebugRuntimeStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetDebugRuntimeStats(ctx, req.(*GetDebugRuntimeStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetLogsStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLogsStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetLogsStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetLogsStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetLogsStats(ctx, req.(*GetLogsStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_ListLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).ListLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_ListLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).ListLogs(ctx, req.(*ListLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_DeleteLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).DeleteLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_DeleteLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).DeleteLogs(ctx, req.(*DeleteLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_CleanupOldLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CleanupOldLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).CleanupOldLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_CleanupOldLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).CleanupOldLogs(ctx, req.(*CleanupOldLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_GetNodeFromHub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeFromHubRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).GetNodeFromHub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_GetNodeFromHub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).GetNodeFromHub(ctx, req.(*GetNodeFromHubRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileLogicService_RegisterNodeWithHub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterNodeWithHubRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileLogicServiceServer).RegisterNodeWithHub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileLogicService_RegisterNodeWithHub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileLogicServiceServer).RegisterNodeWithHub(ctx, req.(*RegisterNodeWithHubRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MobileLogicService_ServiceDesc is the grpc.ServiceDesc for MobileLogicService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MobileLogicService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nitella.local.MobileLogicService",
	HandlerType: (*MobileLogicServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Initialize",
			Handler:    _MobileLogicService_Initialize_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _MobileLogicService_Shutdown_Handler,
		},
		{
			MethodName: "GetBootstrapState",
			Handler:    _MobileLogicService_GetBootstrapState_Handler,
		},
		{
			MethodName: "GetIdentity",
			Handler:    _MobileLogicService_GetIdentity_Handler,
		},
		{
			MethodName: "CreateIdentity",
			Handler:    _MobileLogicService_CreateIdentity_Handler,
		},
		{
			MethodName: "RestoreIdentity",
			Handler:    _MobileLogicService_RestoreIdentity_Handler,
		},
		{
			MethodName: "ImportIdentity",
			Handler:    _MobileLogicService_ImportIdentity_Handler,
		},
		{
			MethodName: "UnlockIdentity",
			Handler:    _MobileLogicService_UnlockIdentity_Handler,
		},
		{
			MethodName: "LockIdentity",
			Handler:    _MobileLogicService_LockIdentity_Handler,
		},
		{
			MethodName: "ChangePassphrase",
			Handler:    _MobileLogicService_ChangePassphrase_Handler,
		},
		{
			MethodName: "EvaluatePassphrase",
			Handler:    _MobileLogicService_EvaluatePassphrase_Handler,
		},
		{
			MethodName: "ResetIdentity",
			Handler:    _MobileLogicService_ResetIdentity_Handler,
		},
		{
			MethodName: "ListNodes",
			Handler:    _MobileLogicService_ListNodes_Handler,
		},
		{
			MethodName: "GetNode",
			Handler:    _MobileLogicService_GetNode_Handler,
		},
		{
			MethodName: "GetNodeDetailSnapshot",
			Handler:    _MobileLogicService_GetNodeDetailSnapshot_Handler,
		},
		{
			MethodName: "UpdateNode",
			Handler:    _MobileLogicService_UpdateNode_Handler,
		},
		{
			MethodName: "RemoveNode",
			Handler:    _MobileLogicService_RemoveNode_Handler,
		},
		{
			MethodName: "AddNodeDirect",
			Handler:    _MobileLogicService_AddNodeDirect_Handler,
		},
		{
			MethodName: "TestDirectConnection",
			Handler:    _MobileLogicService_TestDirectConnection_Handler,
		},
		{
			MethodName: "ListProxies",
			Handler:    _MobileLogicService_ListProxies_Handler,
		},
		{
			MethodName: "GetProxiesSnapshot",
			Handler:    _MobileLogicService_GetProxiesSnapshot_Handler,
		},
		{
			MethodName: "GetProxy",
			Handler:    _MobileLogicService_GetProxy_Handler,
		},
		{
			MethodName: "AddProxy",
			Handler:    _MobileLogicService_AddProxy_Handler,
		},
		{
			MethodName: "UpdateProxy",
			Handler:    _MobileLogicService_UpdateProxy_Handler,
		},
		{
			MethodName: "SetNodeProxiesRunning",
			Handler:    _MobileLogicService_SetNodeProxiesRunning_Handler,
		},
		{
			MethodName: "RemoveProxy",
			Handler:    _MobileLogicService_RemoveProxy_Handler,
		},
		{
			MethodName: "ListRules",
			Handler:    _MobileLogicService_ListRules_Handler,
		},
		{
			MethodName: "GetRule",
			Handler:    _MobileLogicService_GetRule_Handler,
		},
		{
			MethodName: "AddRule",
			Handler:    _MobileLogicService_AddRule_Handler,
		},
		{
			MethodName: "AddQuickRule",
			Handler:    _MobileLogicService_AddQuickRule_Handler,
		},
		{
			MethodName: "UpdateRule",
			Handler:    _MobileLogicService_UpdateRule_Handler,
		},
		{
			MethodName: "RemoveRule",
			Handler:    _MobileLogicService_RemoveRule_Handler,
		},
		{
			MethodName: "BlockIP",
			Handler:    _MobileLogicService_BlockIP_Handler,
		},
		{
			MethodName: "BlockISP",
			Handler:    _MobileLogicService_BlockISP_Handler,
		},
		{
			MethodName: "BlockCountry",
			Handler:    _MobileLogicService_BlockCountry_Handler,
		},
		{
			MethodName: "AddGlobalRule",
			Handler:    _MobileLogicService_AddGlobalRule_Handler,
		},
		{
			MethodName: "ListGlobalRules",
			Handler:    _MobileLogicService_ListGlobalRules_Handler,
		},
		{
			MethodName: "RemoveGlobalRule",
			Handler:    _MobileLogicService_RemoveGlobalRule_Handler,
		},
		{
			MethodName: "ListPendingApprovals",
			Handler:    _MobileLogicService_ListPendingApprovals_Handler,
		},
		{
			MethodName: "GetApprovalsSnapshot",
			Handler:    _MobileLogicService_GetApprovalsSnapshot_Handler,
		},
		{
			MethodName: "ApproveRequest",
			Handler:    _MobileLogicService_ApproveRequest_Handler,
		},
		{
			MethodName: "DenyRequest",
			Handler:    _MobileLogicService_DenyRequest_Handler,
		},
		{
			MethodName: "ResolveApprovalDecision",
			Handler:    _MobileLogicService_ResolveApprovalDecision_Handler,
		},
		{
			MethodName: "ListApprovalHistory",
			Handler:    _MobileLogicService_ListApprovalHistory_Handler,
		},
		{
			MethodName: "ClearApprovalHistory",
			Handler:    _MobileLogicService_ClearApprovalHistory_Handler,
		},
		{
			MethodName: "GetConnectionStats",
			Handler:    _MobileLogicService_GetConnectionStats_Handler,
		},
		{
			MethodName: "ListConnections",
			Handler:    _MobileLogicService_ListConnections_Handler,
		},
		{
			MethodName: "GetIPStats",
			Handler:    _MobileLogicService_GetIPStats_Handler,
		},
		{
			MethodName: "GetGeoStats",
			Handler:    _MobileLogicService_GetGeoStats_Handler,
		},
		{
			MethodName: "CloseConnection",
			Handler:    _MobileLogicService_CloseConnection_Handler,
		},
		{
			MethodName: "CloseAllConnections",
			Handler:    _MobileLogicService_CloseAllConnections_Handler,
		},
		{
			MethodName: "CloseAllNodeConnections",
			Handler:    _MobileLogicService_CloseAllNodeConnections_Handler,
		},
		{
			MethodName: "StartPairing",
			Handler:    _MobileLogicService_StartPairing_Handler,
		},
		{
			MethodName: "JoinPairing",
			Handler:    _MobileLogicService_JoinPairing_Handler,
		},
		{
			MethodName: "CompletePairing",
			Handler:    _MobileLogicService_CompletePairing_Handler,
		},
		{
			MethodName: "FinalizePairing",
			Handler:    _MobileLogicService_FinalizePairing_Handler,
		},
		{
			MethodName: "CancelPairing",
			Handler:    _MobileLogicService_CancelPairing_Handler,
		},
		{
			MethodName: "GenerateQRCode",
			Handler:    _MobileLogicService_GenerateQRCode_Handler,
		},
		{
			MethodName: "ScanQRCode",
			Handler:    _MobileLogicService_ScanQRCode_Handler,
		},
		{
			MethodName: "GenerateQRResponse",
			Handler:    _MobileLogicService_GenerateQRResponse_Handler,
		},
		{
			MethodName: "ListTemplates",
			Handler:    _MobileLogicService_ListTemplates_Handler,
		},
		{
			MethodName: "GetTemplate",
			Handler:    _MobileLogicService_GetTemplate_Handler,
		},
		{
			MethodName: "CreateTemplate",
			Handler:    _MobileLogicService_CreateTemplate_Handler,
		},
		{
			MethodName: "ApplyTemplate",
			Handler:    _MobileLogicService_ApplyTemplate_Handler,
		},
		{
			MethodName: "DeleteTemplate",
			Handler:    _MobileLogicService_DeleteTemplate_Handler,
		},
		{
			MethodName: "SyncTemplates",
			Handler:    _MobileLogicService_SyncTemplates_Handler,
		},
		{
			MethodName: "ExportTemplateYaml",
			Handler:    _MobileLogicService_ExportTemplateYaml_Handler,
		},
		{
			MethodName: "ImportTemplateYaml",
			Handler:    _MobileLogicService_ImportTemplateYaml_Handler,
		},
		{
			MethodName: "GetSettings",
			Handler:    _MobileLogicService_GetSettings_Handler,
		},
		{
			MethodName: "GetSettingsOverviewSnapshot",
			Handler:    _MobileLogicService_GetSettingsOverviewSnapshot_Handler,
		},
		{
			MethodName: "UpdateSettings",
			Handler:    _MobileLogicService_UpdateSettings_Handler,
		},
		{
			MethodName: "RegisterFCMToken",
			Handler:    _MobileLogicService_RegisterFCMToken_Handler,
		},
		{
			MethodName: "UnregisterFCMToken",
			Handler:    _MobileLogicService_UnregisterFCMToken_Handler,
		},
		{
			MethodName: "ConnectToHub",
			Handler:    _MobileLogicService_ConnectToHub_Handler,
		},
		{
			MethodName: "DisconnectFromHub",
			Handler:    _MobileLogicService_DisconnectFromHub_Handler,
		},
		{
			MethodName: "GetHubStatus",
			Handler:    _MobileLogicService_GetHubStatus_Handler,
		},
		{
			MethodName: "GetHubSettingsSnapshot",
			Handler:    _MobileLogicService_GetHubSettingsSnapshot_Handler,
		},
		{
			MethodName: "GetHubOverview",
			Handler:    _MobileLogicService_GetHubOverview_Handler,
		},
		{
			MethodName: "GetHubDashboardSnapshot",
			Handler:    _MobileLogicService_GetHubDashboardSnapshot_Handler,
		},
		{
			MethodName: "RegisterUser",
			Handler:    _MobileLogicService_RegisterUser_Handler,
		},
		{
			MethodName: "FetchHubCA",
			Handler:    _MobileLogicService_FetchHubCA_Handler,
		},
		{
			MethodName: "OnboardHub",
			Handler:    _MobileLogicService_OnboardHub_Handler,
		},
		{
			MethodName: "EnsureHubConnected",
			Handler:    _MobileLogicService_EnsureHubConnected_Handler,
		},
		{
			MethodName: "EnsureHubRegistered",
			Handler:    _MobileLogicService_EnsureHubRegistered_Handler,
		},
		{
			MethodName: "ResolveHubTrustChallenge",
			Handler:    _MobileLogicService_ResolveHubTrustChallenge_Handler,
		},
		{
			MethodName: "GetP2PStatus",
			Handler:    _MobileLogicService_GetP2PStatus_Handler,
		},
		{
			MethodName: "GetP2PSettingsSnapshot",
			Handler:    _MobileLogicService_GetP2PSettingsSnapshot_Handler,
		},
		{
			MethodName: "SetP2PMode",
			Handler:    _MobileLogicService_SetP2PMode_Handler,
		},
		{
			MethodName: "LookupIP",
			Handler:    _MobileLogicService_LookupIP_Handler,
		},
		{
			MethodName: "ConfigureGeoIP",
			Handler:    _MobileLogicService_ConfigureGeoIP_Handler,
		},
		{
			MethodName: "GetGeoIPStatus",
			Handler:    _MobileLogicService_GetGeoIPStatus_Handler,
		},
		{
			MethodName: "RestartListeners",
			Handler:    _MobileLogicService_RestartListeners_Handler,
		},
		{
			MethodName: "ListLocalProxyConfigs",
			Handler:    _MobileLogicService_ListLocalProxyConfigs_Handler,
		},
		{
			MethodName: "GetLocalProxyConfig",
			Handler:    _MobileLogicService_GetLocalProxyConfig_Handler,
		},
		{
			MethodName: "ImportLocalProxyConfig",
			Handler:    _MobileLogicService_ImportLocalProxyConfig_Handler,
		},
		{
			MethodName: "SaveLocalProxyConfig",
			Handler:    _MobileLogicService_SaveLocalProxyConfig_Handler,
		},
		{
			MethodName: "DeleteLocalProxyConfig",
			Handler:    _MobileLogicService_DeleteLocalProxyConfig_Handler,
		},
		{
			MethodName: "ValidateLocalProxyConfig",
			Handler:    _MobileLogicService_ValidateLocalProxyConfig_Handler,
		},
		{
			MethodName: "PushProxyRevision",
			Handler:    _MobileLogicService_PushProxyRevision_Handler,
		},
		{
			MethodName: "PushLocalProxyRevision",
			Handler:    _MobileLogicService_PushLocalProxyRevision_Handler,
		},
		{
			MethodName: "PullProxyRevision",
			Handler:    _MobileLogicService_PullProxyRevision_Handler,
		},
		{
			MethodName: "DiffProxyRevisions",
			Handler:    _MobileLogicService_DiffProxyRevisions_Handler,
		},
		{
			MethodName: "ListProxyRevisions",
			Handler:    _MobileLogicService_ListProxyRevisions_Handler,
		},
		{
			MethodName: "FlushProxyRevisions",
			Handler:    _MobileLogicService_FlushProxyRevisions_Handler,
		},
		{
			MethodName: "ListProxyConfigs",
			Handler:    _MobileLogicService_ListProxyConfigs_Handler,
		},
		{
			MethodName: "CreateProxyConfig",
			Handler:    _MobileLogicService_CreateProxyConfig_Handler,
		},
		{
			MethodName: "DeleteProxyConfig",
			Handler:    _MobileLogicService_DeleteProxyConfig_Handler,
		},
		{
			MethodName: "ApplyProxyToNode",
			Handler:    _MobileLogicService_ApplyProxyToNode_Handler,
		},
		{
			MethodName: "UnapplyProxyFromNode",
			Handler:    _MobileLogicService_UnapplyProxyFromNode_Handler,
		},
		{
			MethodName: "GetAppliedProxies",
			Handler:    _MobileLogicService_GetAppliedProxies_Handler,
		},
		{
			MethodName: "AllowIP",
			Handler:    _MobileLogicService_AllowIP_Handler,
		},
		{
			MethodName: "GetDebugRuntimeStats",
			Handler:    _MobileLogicService_GetDebugRuntimeStats_Handler,
		},
		{
			MethodName: "GetLogsStats",
			Handler:    _MobileLogicService_GetLogsStats_Handler,
		},
		{
			MethodName: "ListLogs",
			Handler:    _MobileLogicService_ListLogs_Handler,
		},
		{
			MethodName: "DeleteLogs",
			Handler:    _MobileLogicService_DeleteLogs_Handler,
		},
		{
			MethodName: "CleanupOldLogs",
			Handler:    _MobileLogicService_CleanupOldLogs_Handler,
		},
		{
			MethodName: "GetNodeFromHub",
			Handler:    _MobileLogicService_GetNodeFromHub_Handler,
		},
		{
			MethodName: "RegisterNodeWithHub",
			Handler:    _MobileLogicService_RegisterNodeWithHub_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamApprovals",
			Handler:       _MobileLogicService_StreamApprovals_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamConnections",
			Handler:       _MobileLogicService_StreamConnections_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamP2PStatus",
			Handler:       _MobileLogicService_StreamP2PStatus_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamMetrics",
			Handler:       _MobileLogicService_StreamMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "local/nitella_local.proto",
}

const (
	MobileUIService_OnApprovalRequest_FullMethodName  = "/nitella.local.MobileUIService/OnApprovalRequest"
	MobileUIService_OnNodeStatusChange_FullMethodName = "/nitella.local.MobileUIService/OnNodeStatusChange"
	MobileUIService_OnConnectionEvent_FullMethodName  = "/nitella.local.MobileUIService/OnConnectionEvent"
	MobileUIService_OnAlert_FullMethodName            = "/nitella.local.MobileUIService/OnAlert"
	MobileUIService_OnToast_FullMethodName            = "/nitella.local.MobileUIService/OnToast"
)

// MobileUIServiceClient is the client API for MobileUIService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MobileUIServiceClient interface {
	// New approval request arrived
	OnApprovalRequest(ctx context.Context, in *ApprovalRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Node status changed (online/offline)
	OnNodeStatusChange(ctx context.Context, in *NodeStatusChange, opts ...grpc.CallOption) (*empty.Empty, error)
	// Connection event (new connection, closed, blocked)
	OnConnectionEvent(ctx context.Context, in *ConnectionEvent, opts ...grpc.CallOption) (*empty.Empty, error)
	// Alert notification
	OnAlert(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*empty.Empty, error)
	// Toast message
	OnToast(ctx context.Context, in *ToastMessage, opts ...grpc.CallOption) (*empty.Empty, error)
}

type mobileUIServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMobileUIServiceClient(cc grpc.ClientConnInterface) MobileUIServiceClient {
	return &mobileUIServiceClient{cc}
}

func (c *mobileUIServiceClient) OnApprovalRequest(ctx context.Context, in *ApprovalRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileUIService_OnApprovalRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileUIServiceClient) OnNodeStatusChange(ctx context.Context, in *NodeStatusChange, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileUIService_OnNodeStatusChange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileUIServiceClient) OnConnectionEvent(ctx context.Context, in *ConnectionEvent, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileUIService_OnConnectionEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileUIServiceClient) OnAlert(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileUIService_OnAlert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mobileUIServiceClient) OnToast(ctx context.Context, in *ToastMessage, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MobileUIService_OnToast_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MobileUIServiceServer is the server API for MobileUIService service.
// All implementations must embed UnimplementedMobileUIServiceServer
// for forward compatibility.
type MobileUIServiceServer interface {
	// New approval request arrived
	OnApprovalRequest(context.Context, *ApprovalRequest) (*empty.Empty, error)
	// Node status changed (online/offline)
	OnNodeStatusChange(context.Context, *NodeStatusChange) (*empty.Empty, error)
	// Connection event (new connection, closed, blocked)
	OnConnectionEvent(context.Context, *ConnectionEvent) (*empty.Empty, error)
	// Alert notification
	OnAlert(context.Context, *Alert) (*empty.Empty, error)
	// Toast message
	OnToast(context.Context, *ToastMessage) (*empty.Empty, error)
	mustEmbedUnimplementedMobileUIServiceServer()
}

// UnimplementedMobileUIServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMobileUIServiceServer struct{}

func (UnimplementedMobileUIServiceServer) OnApprovalRequest(context.Context, *ApprovalRequest) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method OnApprovalRequest not implemented")
}
func (UnimplementedMobileUIServiceServer) OnNodeStatusChange(context.Context, *NodeStatusChange) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method OnNodeStatusChange not implemented")
}
func (UnimplementedMobileUIServiceServer) OnConnectionEvent(context.Context, *ConnectionEvent) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method OnConnectionEvent not implemented")
}
func (UnimplementedMobileUIServiceServer) OnAlert(context.Context, *Alert) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method OnAlert not implemented")
}
func (UnimplementedMobileUIServiceServer) OnToast(context.Context, *ToastMessage) (*empty.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method OnToast not implemented")
}
func (UnimplementedMobileUIServiceServer) mustEmbedUnimplementedMobileUIServiceServer() {}
func (UnimplementedMobileUIServiceServer) testEmbeddedByValue()                         {}

// UnsafeMobileUIServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MobileUIServiceServer will
// result in compilation errors.
type UnsafeMobileUIServiceServer interface {
	mustEmbedUnimplementedMobileUIServiceServer()
}

func RegisterMobileUIServiceServer(s grpc.ServiceRegistrar, srv MobileUIServiceServer) {
	// If the following call panics, it indicates UnimplementedMobileUIServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MobileUIService_ServiceDesc, srv)
}

func _MobileUIService_OnApprovalRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApprovalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileUIServiceServer).OnApprovalRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileUIService_OnApprovalRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileUIServiceServer).OnApprovalRequest(ctx, req.(*ApprovalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileUIService_OnNodeStatusChange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeStatusChange)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileUIServiceServer).OnNodeStatusChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileUIService_OnNodeStatusChange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileUIServiceServer).OnNodeStatusChange(ctx, req.(*NodeStatusChange))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileUIService_OnConnectionEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectionEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileUIServiceServer).OnConnectionEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileUIService_OnConnectionEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileUIServiceServer).OnConnectionEvent(ctx, req.(*ConnectionEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileUIService_OnAlert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Alert)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileUIServiceServer).OnAlert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileUIService_OnAlert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileUIServiceServer).OnAlert(ctx, req.(*Alert))
	}
	return interceptor(ctx, in, info, handler)
}

func _MobileUIService_OnToast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToastMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MobileUIServiceServer).OnToast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MobileUIService_OnToast_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MobileUIServiceServer).OnToast(ctx, req.(*ToastMessage))
	}
	return interceptor(ctx, in, info, handler)
}

// MobileUIService_ServiceDesc is the grpc.ServiceDesc for MobileUIService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MobileUIService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nitella.local.MobileUIService",
	HandlerType: (*MobileUIServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnApprovalRequest",
			Handler:    _MobileUIService_OnApprovalRequest_Handler,
		},
		{
			MethodName: "OnNodeStatusChange",
			Handler:    _MobileUIService_OnNodeStatusChange_Handler,
		},
		{
			MethodName: "OnConnectionEvent",
			Handler:    _MobileUIService_OnConnectionEvent_Handler,
		},
		{
			MethodName: "OnAlert",
			Handler:    _MobileUIService_OnAlert_Handler,
		},
		{
			MethodName: "OnToast",
			Handler:    _MobileUIService_OnToast_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "local/nitella_local.proto",
}
